{
	// Place your algorithm ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BIT": {
		"scope": "cpp",
		"prefix": "BIT",
		"body": [
			"// Binary Indexed Tree.",
			"template <typename T>",
			"class BIT {",
			"    int m_sz;               // m_sz:=(配列の要素数).",
			"    std::vector<T> m_tree;  // 1-based index.",
			"",
			"    void build() {",
			"        for(int i = 1; i < size(); ++i) {",
			"            int j = i + (i & -i);",
			"            if(j <= size()) m_tree[j] += m_tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT() : BIT(0){};",
			"    explicit BIT(size_t n, T a = 0) : m_sz(n), m_tree(n + 1, a) {",
			"        if(a != 0) build();",
			"    }",
			"    explicit BIT(const std::vector<T> &v) : m_sz(v.size()), m_tree(v.size() + 1) {",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + 1);",
			"        build();",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // k番目の要素にaを加算する．O(logN).",
			"    void add(int k, T a) {",
			"        assert(1 <= k and k <= size());",
			"        for(; k <= size(); k += k & -k) m_tree[k] += a;",
			"    }",
			"    // 区間[1,r]の要素の総和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= size());",
			"        T res = 0;",
			"        for(; r > 0; r -= r & -r) res += m_tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r]の要素の総和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(1 <= l and l <= r and r <= size());",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(m_tree.begin() + 1, m_tree.end(), a);",
			"        if(a != 0) build();",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree"
	},
	"BIT0": {
		"scope": "cpp",
		"prefix": "BIT0",
		"body": [
			"// Binary Indexed Tree (0-based index).",
			"template <typename T>",
			"class BIT0 {",
			"    int m_sz;               // m_sz:=(配列の要素数).",
			"    std::vector<T> m_tree;  // 0-based index.",
			"",
			"    void build() {",
			"        for(int i = 0; i < size() - 1; ++i) {",
			"            int j = i | (i + 1);",
			"            if(j < size()) m_tree[j] += m_tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT0() : BIT0(0){};",
			"    explicit BIT0(size_t n, T a = 0) : m_sz(n), m_tree(n, a) {",
			"        if(a != 0) build();",
			"    }",
			"    explicit BIT0(const std::vector<T> &v) : m_sz(v.size()), m_tree(v) {",
			"        build();",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // k番目の要素にaを加算する．O(logN).",
			"    void add(int k, T a) {",
			"        assert(0 <= k and k < size());",
			"        for(; k < size(); k |= k + 1) m_tree[k] += a;",
			"    }",
			"    // 区間[0,r)の要素の総和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= size());",
			"        T res = 0;",
			"        for(r = r - 1; r >= 0; r = (r & (r + 1)) - 1) res += m_tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r)の要素の総和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        return sum(r) - sum(l);",
			"    }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(m_tree.begin(), m_tree.end(), a);",
			"        if(a != 0) build();",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree (0-based index)"
	},
	"BIT2D": {
		"scope": "cpp",
		"prefix": "BIT2D",
		"body": [
			"// 2次元BIT．",
			"template <typename T>",
			"class BIT2D {",
			"    int m_h, m_w;",
			"    std::vector<std::vector<T> > m_dat;  // 1-based index.",
			"",
			"    void build() {",
			"        for(int i = 1; i <= height(); ++i)",
			"            for(int j = 1; j <= width(); ++j) {",
			"                int ni = i + (i & -i), nj = j + (j & -j);",
			"                bool flag1 = (ni <= height()), flag2 = (nj <= width());",
			"                if(flag1) m_dat[ni][j] += m_dat[i][j];",
			"                if(flag2) m_dat[i][nj] += m_dat[i][j];",
			"                if(flag1 and flag2) m_dat[ni][nj] -= m_dat[i][j];",
			"            }",
			"    }",
			"",
			"public:",
			"    // constructor. O(H*W).",
			"    BIT2D() : BIT2D(0, 0) {}",
			"    explicit BIT2D(size_t h, size_t w, T a = 0) : m_h(h), m_w(w), m_dat(h + 1, std::vector<T>(w + 1, a)) {",
			"        if(a != 0) build();",
			"    }",
			"    explicit BIT2D(const std::vector<std::vector<T> > &dat)",
			"        : m_h(dat.size()), m_w(dat[0].size()), m_dat(dat.size() + 1, std::vector<T>(dat[0].size() + 1)) {",
			"        for(int i = 0; i < height(); ++i) std::copy(dat[i].begin(), dat[i].end(), m_dat[i + 1].begin() + 1);",
			"        build();",
			"    }",
			"",
			"    int height() const { return m_h; }",
			"    int width() const { return m_w; }",
			"    // 要素(x,y)にaを加算する．O((logH)*logW).",
			"    void add(int y, int x, T a) {",
			"        assert(1 <= y and y <= height());",
			"        assert(1 <= x and x <= width());",
			"        for(int i = y; i <= height(); i += i & -i) {",
			"            for(int j = x; j <= width(); j += j & -j) m_dat[i][j] += a;",
			"        }",
			"    }",
			"    // 区間[1,y]かつ[1,x]の総和を求める．O((logH)*logW).",
			"    T sum(int y, int x) const {",
			"        assert(0 <= y and y <= height());",
			"        assert(0 <= x and x <= width());",
			"        T res = 0;",
			"        for(int i = y; i > 0; i -= i & -i) {",
			"            for(int j = x; j > 0; j -= j & -j) res += m_dat[i][j];",
			"        }",
			"        return res;",
			"    }",
			"    // 区間[y,yy]かつ[x,xx]の総和を求める．",
			"    T sum(int y, int x, int yy, int xx) const {",
			"        assert(1 <= y and y <= yy and yy <= height());",
			"        assert(1 <= x and x <= xx and xx <= width());",
			"        return sum(yy, xx) - sum(yy, x - 1) - sum(y - 1, xx) + sum(y - 1, x - 1);",
			"    }",
			"    // 全要素をaで埋める．O(H*W).",
			"    void fill(T a = 0) {",
			"        for(int i = 1; i <= height(); ++i) std::fill(m_dat[i].begin() + 1, m_dat[i].end(), a);",
			"        if(a != 0) build();",
			"    }",
			"};"
		],
		"description": "2次元BIT"
	},
	"BIT2D0": {
		"scope": "cpp",
		"prefix": "BIT2D0",
		"body": [
			"// 2次元BIT (0-based index)．",
			"template <typename T>",
			"class BIT2D0 {",
			"    int m_h, m_w;",
			"    std::vector<std::vector<T> > m_dat;  // 0-based index.",
			"",
			"    void build() {",
			"        for(int i = 0; i < height(); ++i) {",
			"            for(int j = 0; j < width(); ++j) {",
			"                int ni = i | i + 1, nj = j | j + 1;",
			"                bool flag1 = (ni < height()), flag2 = (nj < width());",
			"                if(flag1) m_dat[ni][j] += m_dat[i][j];",
			"                if(flag2) m_dat[i][nj] += m_dat[i][j];",
			"                if(flag1 and flag2) m_dat[ni][nj] -= m_dat[i][j];",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(H*W).",
			"    BIT2D0() : BIT2D0(0, 0) {}",
			"    explicit BIT2D0(size_t h, size_t w, T a = 0) : m_h(h), m_w(w), m_dat(h, std::vector<T>(w, a)) {",
			"        if(a != 0) build();",
			"    }",
			"    explicit BIT2D0(const std::vector<std::vector<T> > &dat) : m_h(dat.size()), m_w(dat[0].size()), m_dat(dat) {",
			"        build();",
			"    }",
			"",
			"    int height() const { return m_h; }",
			"    int width() const { return m_w; }",
			"    // 座標(x,y)にaを加算する．O((logH)*logW).",
			"    void add(int y, int x, T a) {",
			"        assert(0 <= y and y < height());",
			"        assert(0 <= x and x < width());",
			"        for(int i = y; i < height(); i |= i + 1) {",
			"            for(int j = x; j < width(); j |= j + 1) m_dat[i][j] += a;",
			"        }",
			"    }",
			"    // 区間[0,y)かつ[0,x)の総和を求める．O((logH)*logW).",
			"    T sum(int y, int x) const {",
			"        assert(0 <= y and y <= height());",
			"        assert(0 <= x and x <= width());",
			"        T res = 0;",
			"        for(int i = y - 1; i >= 0; i = (i & i + 1) - 1) {",
			"            for(int j = x - 1; j >= 0; j = (j & j + 1) - 1) res += m_dat[i][j];",
			"        }",
			"        return res;",
			"    }",
			"    // 区間[y,yy)かつ[x,xx)の総和を求める．",
			"    T sum(int y, int x, int yy, int xx) const {",
			"        assert(0 <= y and y <= yy and yy <= height());",
			"        assert(0 <= x and x <= xx and xx <= width());",
			"        return sum(yy, xx) - sum(yy, x) - sum(y, xx) + sum(y, x);",
			"    }",
			"    // 全要素をaで埋める．O(H*W).",
			"    void fill(T a = 0) {",
			"        for(int i = 0; i < height(); ++i) std::fill(m_dat[i].begin(), m_dat[i].end(), a);",
			"        if(a != 0) build();",
			"    }",
			"};"
		],
		"description": "2次元BIT (0-based index)"
	},
	"BellmanFord": {
		"scope": "cpp",
		"prefix": "BellmanFord",
		"body": [
			"template <typename T>",
			"class BellmanFord {",
			"    struct Edge {",
			"        int from, to;",
			"        T cost;",
			"        explicit Edge(int from_, int to_, T cost_) : from(from_), to(to_), cost(cost_) {}",
			"    };",
			"",
			"    int m_vn;                   // m_vn:=(ノード数).",
			"    std::vector<Edge> m_edges;  // m_edges[]:=(辺リスト).",
			"    std::vector<T> m_d;         // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;     // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"",
			"public:",
			"    BellmanFord() : BellmanFord(0) {}",
			"    explicit BellmanFord(size_t vn) : m_vn(vn), m_d(vn, infinity()), m_pre(vn, -1) {}",
			"    explicit BellmanFord(size_t vn, size_t en) : BellmanFord(vn) {",
			"        m_edges.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 辺数を返す．",
			"    int size() const { return m_edges.size(); }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_edges.emplace_back(from, to, cost);",
			"    }",
			"    // グラフ全体から負閉路を検出する．O(|V|*|E|).",
			"    bool find_negative_cycle() const {",
			"        std::vector<T> nd(order(), 0);",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(nd[to] > nd[from] + cost) {",
			"                    nd[to] = nd[from] + cost;",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) return false;  // 負閉路なし．",
			"        }",
			"        return true;  // 負閉路あり．",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|V|*|E|).",
			"    bool bellman_ford(int s) {",
			"        assert(0 <= s and s < order());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(m_d[from] == infinity()) continue;",
			"                if(m_d[to] > m_d[from] + cost) {",
			"                    m_d[to] = m_d[from] + cost;",
			"                    m_pre[to] = from;",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) return false;  // 負閉路なし．",
			"        }",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(m_d[from] == infinity() or m_d[to] == -infinity()) continue;",
			"                if(m_d[from] == -infinity() or m_d[to] > m_d[from] + cost) {",
			"                    m_d[to] = -infinity();",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) break;",
			"        }",
			"        return true;  // 負閉路あり．",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < order());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> shortest_path(int t) const {",
			"        assert(0 <= t and t < order());",
			"        std::vector<int> path;",
			"        if(distance(t) == infinity() or distance(t) == -infinity()) return path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "Bellman-Ford Algorithm（単一始点最短経路）"
	},
	"BinaryTrie": {
		"scope": "cpp",
		"prefix": "BinaryTrie",
		"body": [
			"// 非負整数値を要素とする多重集合．",
			"template <size_t B = 32>  // B:ビット長.",
			"class BinaryTrie {",
			"public:",
			"    using size_type = uint64_t;",
			"",
			"private:",
			"    struct Node {",
			"        size_type cnt;  // cnt:=(自身を根とする部分木に含まれる要素数).",
			"        Node *ch[2];    // ch[]:=(子のポインタ).",
			"        Node() : cnt(0) {",
			"            ch[0] = ch[1] = nullptr;",
			"        }",
			"    };",
			"",
			"    Node *m_root;           // m_root:=(根のポインタ).",
			"    std::bitset<B> m_bias;  // m_bias:=(xorの操作を行う値).",
			"",
			"    Node *find(const std::bitset<B> &x) const {",
			"        if(m_root == nullptr) return nullptr;",
			"        Node *p = m_root;",
			"        for(int i = B - 1; i >= 0; --i) {",
			"            p = p->ch[x[i] ^ m_bias[i]];",
			"            if(p == nullptr) return nullptr;",
			"        }",
			"        return p;",
			"    }",
			"    Node *add(Node *p, const std::bitset<B> &x, size_type cnt, int shift = B - 1) {  // Top down.",
			"        if(p == nullptr) p = new Node;",
			"        p->cnt += cnt;",
			"        if(shift >= 0) {",
			"            bool bit = x[shift] ^ m_bias[shift];",
			"            p->ch[bit] = add(p->ch[bit], x, cnt, shift - 1);",
			"        }",
			"        return p;",
			"    }",
			"    Node *sub(Node *p, const std::bitset<B> &x, size_type cnt, int shift = B - 1) {  // Bottom up.",
			"        assert(p and p->cnt >= cnt);",
			"        if(shift >= 0) {",
			"            bool bit = x[shift] ^ m_bias[shift];",
			"            p->ch[bit] = sub(p->ch[bit], x, cnt, shift - 1);",
			"        }",
			"        p->cnt -= cnt;",
			"        if(p->cnt == 0) {",
			"            delete p;",
			"            p = nullptr;",
			"        }",
			"        return p;",
			"    }",
			"    std::bitset<B> get(Node *p, size_type k, int shift = B - 1) const {",
			"        assert(p);",
			"        if(shift < 0) return 0;",
			"        bool bit = m_bias[shift];",
			"        size_type m = (p->ch[bit] ? p->ch[bit]->cnt : 0);",
			"        if(k < m) return get(p->ch[bit], k, shift - 1);",
			"        return std::bitset<B>(0).set(shift) | get(p->ch[!bit], k - m, shift - 1);",
			"    }",
			"    size_type get_lower(Node *p, const std::bitset<B> &x, int shift = B - 1) const {",
			"        if(p == nullptr or shift < 0) return 0;",
			"        bool bit = x[shift] ^ m_bias[shift];",
			"        return (x[shift] and p->ch[!bit] ? p->ch[!bit]->cnt : 0) + get_lower(p->ch[bit], x, shift - 1);",
			"    }",
			"    size_type get_upper(Node *p, const std::bitset<B> &x, int shift = B - 1) const {",
			"        if(p == nullptr) return 0;",
			"        if(shift < 0) return p->cnt;",
			"        bool bit = x[shift] ^ m_bias[shift];",
			"        return (x[shift] and p->ch[!bit] ? p->ch[!bit]->cnt : 0) + get_upper(p->ch[bit], x, shift - 1);",
			"    }",
			"    Node *dfs_clear(Node *p) {",
			"        if(p == nullptr) return nullptr;",
			"        for(bool bit : {0, 1}) p->ch[bit] = dfs_clear(p->ch[bit]);",
			"        delete p;",
			"        return p = nullptr;",
			"    }",
			"    void dfs_print(std::ostream &os, Node *p, std::bitset<B> &x, int &cnt, int shift = B - 1) const {",
			"        if(shift < 0) {",
			"            os << (cnt == 0 ? \"\" : \"\\n \") << \"{\" << x << \" (\" << x.to_ullong() << \"), \" << p->cnt << \"}\";",
			"            cnt++;",
			"            return;",
			"        }",
			"        for(bool bit : {0, 1}) {",
			"            x[shift] = bit;",
			"            bit ^= m_bias[shift];",
			"            if(p->ch[bit]) dfs_print(os, p->ch[bit], x, cnt, shift - 1);",
			"        }",
			"    }",
			"",
			"public:",
			"    BinaryTrie() : m_root(nullptr), m_bias(0) {}",
			"    ~BinaryTrie() {",
			"        clear();",
			"    }",
			"",
			"    std::bitset<B> operator[](size_type k) const { return kth_element(k); }",
			"",
			"    // 集合が空かどうか判定する．O(1).",
			"    bool empty() const { return m_root == nullptr; }",
			"    // 全要素数を返す．O(1).",
			"    size_type size() const { return (m_root ? m_root->cnt : 0); }",
			"    // 値xの要素が集合に含まれるか判定する．O(B).",
			"    bool exist(const std::bitset<B> &x) const { return find(x); }",
			"    // 多重集合に含まれる値xの要素数を返す．O(B).",
			"    size_type count(const std::bitset<B> &x) const {",
			"        Node *p = find(x);",
			"        return (p ? p->cnt : 0);",
			"    }",
			"    // 多重集合に値xの要素を追加する．O(B).",
			"    void insert(const std::bitset<B> &x, size_type cnt = 1) {",
			"        if(cnt == 0) return;",
			"        m_root = add(m_root, x, cnt);",
			"    }",
			"    // 多重集合から値xの要素を削除する．O(B).",
			"    void erase(const std::bitset<B> &x, size_type cnt = 1) {",
			"        assert(count(x) >= cnt);",
			"        if(cnt == 0) return;",
			"        m_root = sub(m_root, x, cnt);",
			"    }",
			"    // 集合内で最小の要素値を取得する．O(B).",
			"    std::bitset<B> min_element() const { return kth_element(0); }",
			"    // 集合内で最大の要素値を取得する．O(B).",
			"    std::bitset<B> max_element() const { return kth_element(size() - 1); }",
			"    // 多重集合内でk番目に小さい要素値を取得する．0-based index. O(B).",
			"    std::bitset<B> kth_element(size_type k) const {",
			"        assert(0 <= k and k < size());",
			"        return get(m_root, k);",
			"    }",
			"    // x以上である要素値が現れる最初の位置を取得する．O(B).",
			"    size_type lower_bound(const std::bitset<B> &x) const { return get_lower(m_root, x); }",
			"    // xより大きい要素値が現れる最初の位置を取得する．O(B).",
			"    size_type upper_bound(const std::bitset<B> &x) const { return get_upper(m_root, x); }",
			"    // 全要素値にxorの操作を行う．O(1).",
			"    void operator_xor(const std::bitset<B> &x) { m_bias ^= x; }",
			"    // xorの操作をする値を返す．O(1).",
			"    std::bitset<B> xor_value() const { return m_bias; }",
			"    // 全要素を削除する．",
			"    void clear() { m_root = dfs_clear(m_root); }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const BinaryTrie &ob) {",
			"        std::bitset<B> x(0);",
			"        int cnt = 0;",
			"        os << \"[\";",
			"        if(ob.m_root) ob.dfs_print(os, ob.m_root, x, cnt);",
			"        os << \"]\";",
			"        return os;",
			"    }",
			"};"
		],
		"description": "非負整数値を要素とする多重集合"
	},
	"Combination": {
		"scope": "cpp",
		"prefix": "Combination",
		"body": [
			"// 二項係数（mod付き）．",
			"template <int mod>",
			"class Combination {",
			"    int m_sz;                       // m_sz:=(要素数). 制約は m_sz<=mod．",
			"    std::vector<long long> m_fact;  // m_fact[n]:=(nの階乗).",
			"    std::vector<long long> m_inv;   // m_inv[n]:=(nの逆元).",
			"    std::vector<long long> m_finv;  // m_finv[n]:=(nの階乗の逆元).",
			"",
			"public:",
			"    // constructor. O(N).",
			"    Combination() : Combination(51e4) {}",
			"    explicit Combination(size_t sz) : m_sz(sz), m_fact(sz), m_inv(sz), m_finv(sz) {",
			"        static_assert(mod >= 1);",
			"        assert(2 <= m_sz and m_sz <= mod);",
			"        m_fact[0] = m_fact[1] = 1;",
			"        m_inv[1] = 1;",
			"        m_finv[0] = m_finv[1] = 1;",
			"        for(int n = 2; n < m_sz; ++n) {",
			"            m_fact[n] = m_fact[n - 1] * n % mod;",
			"            m_inv[n] = mod - m_inv[mod % n] * (mod / n) % mod;",
			"            m_finv[n] = m_finv[n - 1] * m_inv[n] % mod;",
			"        }",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // 階乗．",
			"    long long factorial(int n) const {",
			"        assert(0 <= n and n < m_sz);",
			"        return m_fact[n];",
			"    }",
			"    // 逆元．",
			"    long long inverse(int n) const {",
			"        assert(1 <= n and n < m_sz);",
			"        return m_inv[n];",
			"    }",
			"    // 階乗の逆元．",
			"    long long inverse_fact(int n) const {",
			"        assert(0 <= n and n < m_sz);",
			"        return m_finv[n];",
			"    }",
			"    // 順列．",
			"    long long nPk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n < m_sz);",
			"        return m_fact[n] * m_finv[n - k] % mod;",
			"    }",
			"    // 組合せ．",
			"    long long nCk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n < m_sz);",
			"        return m_fact[n] * m_finv[n - k] % mod * m_finv[k] % mod;",
			"    }",
			"    // 重複組合せ．",
			"    long long nHk(int n, int k) const { return nCk(k + n - 1, n - 1); }",
			"};",
			"",
			"using Combination998244353 = Combination<998'244'353>;",
			"using Combination1000000007 = Combination<1'000'000'007>;"
		],
		"description": "二項係数（mod付き）"
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "Dijkstra",
		"body": [
			"template <typename T>",
			"class Dijkstra {",
			"    int m_vn;                                           // m_vn:=(ノード数).",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost).",
			"    std::vector<T> m_d;                                 // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;                             // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"",
			"public:",
			"    Dijkstra() : Dijkstra(0) {}",
			"    explicit Dijkstra(size_t vn) : m_vn(vn), m_g(vn), m_d(vn, infinity()), m_pre(vn, -1) {}",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].emplace_back(to, cost);",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|E|*log|V|).",
			"    void dijkstra(int s) {",
			"        assert(0 <= s and s < order());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, std::greater<std::pair<T, int> > > pque;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            const auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(m_d[v] < dist) continue;",
			"            for(const auto &[to, cost] : m_g[v]) {",
			"                if(m_d[to] > m_d[v] + cost) {",
			"                    m_d[to] = m_d[v] + cost;",
			"                    m_pre[to] = v;",
			"                    pque.emplace(m_d[to], to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < order());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> shortest_path(int t) const {",
			"        assert(0 <= t and t < order());",
			"        std::vector<int> path;",
			"        if(distance(t) == infinity()) return path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "Dijkstra's Algorithm（単一始点最短経路）"
	},
	"Dinic": {
		"scope": "cpp",
		"prefix": "Dinic",
		"body": [
			"template <typename T>  // T:容量の型.",
			"class Dinic {",
			"    struct Edge {",
			"        int to;   // to:=(行き先ノード).",
			"        T cap;    // cap:=(容量).",
			"        int rev;  // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺の情報). pair of (from, index).",
			"",
			"    // ノードsと各ノード間の増加パスの長さを求める．",
			"    void bfs(int s, std::vector<int> &d) const {",
			"        std::fill(d.begin(), d.end(), -1);",
			"        d[s] = 0;",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and d[e.to] == -1) {",
			"                    d[e.to] = d[v] + 1;",
			"                    que.push(e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // 増加パスを探す．",
			"    T dfs(int v, int t, T flow, const std::vector<int> &d, std::vector<int> &iter) {",
			"        if(v == t) return flow;",
			"        const int n = m_g[v].size();",
			"        for(int &i = iter[v]; i < n; ++i) {",
			"            Edge &e = m_g[v][i];",
			"            if(e.cap > 0 and d[e.to] > d[v]) {",
			"                T res = dfs(e.to, t, std::min(flow, e.cap), d, iter);",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    m_g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    Dinic() : Dinic(0) {}",
			"    explicit Dinic(size_t vn) : m_g(vn) {}",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量capの有向辺を追加する．",
			"    int add_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, idx_to);",
			"        m_g[to].emplace_back(from, 0, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ノードsからtへの最大流を求める．O((|V|^2)*|E|).",
			"    T max_flow(int s, int t) { return max_flow(s, t, infinity()); }",
			"    T max_flow(int s, int t, T flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        T res = 0;",
			"        std::vector<int> d(order());     // d[v]:=(ノードs, v間の増加パスの長さ).",
			"        std::vector<int> iter(order());  // iter[v]:=(m_g[v][]の次に調べるべきイテレータ).",
			"        while(res < flow) {",
			"            bfs(s, d);",
			"            if(d[t] == -1) break;",
			"            std::fill(iter.begin(), iter.end(), 0);",
			"            T tmp;",
			"            while(flow - res > 0 and (tmp = dfs(s, t, flow - res, d, iter)) > 0) res += tmp;",
			"        }",
			"        return res;",
			"    }",
			"    // 辺の情報を返す．",
			"    std::tuple<int, int, T, T> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, flow).",
			"    }",
			"    // 最小カットにより，グラフ上のノードを分割する．",
			"    std::vector<bool> min_cut(int s) const {",
			"        assert(0 <= s and s < order());",
			"        std::vector<bool> res(order(), false);",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            if(res[v]) continue;",
			"            res[v] = true;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and !res[e.to]) que.push(e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Dinic's algorithm（最大流）"
	},
	"DynamicModint": {
		"scope": "cpp",
		"prefix": "DynamicModint",
		"body": [
			"template <int id>",
			"class DynamicModint : ModintBase {",
			"    static int mod;",
			"    long long val;",
			"",
			"    void normalize() {",
			"        if(!(-mod <= val and val < mod)) val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"public:",
			"    DynamicModint() : DynamicModint(0) {}",
			"    DynamicModint(long long val_) : val(val_) {",
			"        assert(mod >= 1);",
			"        normalize();",
			"    }",
			"",
			"    DynamicModint operator+() const { return DynamicModint(*this); }",
			"    DynamicModint operator-() const { return (val == 0 ? DynamicModint(*this) : DynamicModint(mod - val)); }",
			"    DynamicModint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    DynamicModint operator++(int) {",
			"        DynamicModint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    DynamicModint operator--(int) {",
			"        DynamicModint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    DynamicModint &operator+=(const DynamicModint &rhs) {",
			"        val += rhs.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator-=(const DynamicModint &rhs) {",
			"        val -= rhs.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator*=(const DynamicModint &rhs) {",
			"        val = val * rhs.val % mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator/=(const DynamicModint &rhs) { return *this *= rhs.inv(); }",
			"",
			"    friend DynamicModint operator+(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) += rhs; }",
			"    friend DynamicModint operator-(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) -= rhs; }",
			"    friend DynamicModint operator*(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) *= rhs; }",
			"    friend DynamicModint operator/(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) /= rhs; }",
			"    friend bool operator==(const DynamicModint &lhs, const DynamicModint &rhs) { return lhs.val == rhs.val; }",
			"    friend bool operator!=(const DynamicModint &lhs, const DynamicModint &rhs) { return lhs.val != rhs.val; }",
			"    friend std::istream &operator>>(std::istream &is, DynamicModint &rhs) {",
			"        is >> rhs.val;",
			"        rhs.normalize();",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const DynamicModint &rhs) { return os << rhs.val; }",
			"",
			"    static constexpr int get_id() { return id; }",
			"    static void set_modulus(int mod_) {",
			"        assert(mod_ >= 1);",
			"        mod = mod_;",
			"    }",
			"    static int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    DynamicModint inv() const {",
			"        long long a = val, b = mod, u = 1, v = 0;",
			"        while(b) {",
			"            long long t = a / b;",
			"            a -= b * t, u -= v * t;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return DynamicModint(u);",
			"    }",
			"    DynamicModint pow(long long k) const {",
			"        if(k < 0) return inv().pow(-k);",
			"        DynamicModint res = 1, mul = *this;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= mul;",
			"            mul *= mul;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend DynamicModint mod_inv(const DynamicModint &a) { return a.inv(); }",
			"    friend DynamicModint mod_pow(const DynamicModint &a, long long k) { return a.pow(k); }",
			"};",
			"",
			"template <int id>",
			"int DynamicModint<id>::mod = 1'000'000'007;"
		],
		"description": "動的modint"
	},
	"FloydWarshall": {
		"scope": "cpp",
		"prefix": "FloydWarshall",
		"body": [
			"template <typename T>",
			"class FloydWarshall {",
			"    int m_vn;                           // m_vn:=(ノード数).",
			"    std::vector<std::vector<T> > m_dp;  // m_dp[s][t]:=(ノードsからtへの最短距離).",
			"",
			"public:",
			"    FloydWarshall() {}",
			"    explicit FloydWarshall(size_t vn) : m_vn(vn), m_dp(vn, std::vector<T>(vn, infinity())) {}",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max() / 2; }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_dp[from][to] = cost;",
			"    }",
			"    // グラフ上の全頂点対間について最短距離を求める．O(|V|^3).",
			"    void floyd_warshall() {",
			"        for(int v = 0; v < order(); ++v) m_dp[v][v] = 0;",
			"        for(int k = 0; k < order(); ++k) {",
			"            for(int s = 0; s < order(); ++s) {",
			"                for(int t = 0; t < order(); ++t) m_dp[s][t] = std::min(m_dp[s][t], m_dp[s][k] + m_dp[k][t]);",
			"            }",
			"        }",
			"    }",
			"    // グラフ全体から負閉路を検出する．O(|V|).",
			"    bool find_negative_cycle() const {",
			"        for(int v = 0; v < order(); ++v) {",
			"            if(m_dp[v][v] < 0) return true;  // 負閉路あり．",
			"        }",
			"        return false;  // 負閉路なし．",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int s, int t) const {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        return m_dp[s][t];",
			"    }",
			"};"
		],
		"description": "Floyd–Warshall Algorithm（全点対間最短経路）"
	},
	"FordFulkerson": {
		"scope": "cpp",
		"prefix": "FordFulkerson",
		"body": [
			"template <typename T>  // T:容量の型.",
			"class FordFulkerson {",
			"    struct Edge {",
			"        int to;   // to:=(行き先ノード).",
			"        T cap;    // cap:=(容量).",
			"        int rev;  // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺の情報). pair of (from, index).",
			"",
			"    // 増加パスを探す．",
			"    T dfs(int v, int t, T flow, std::vector<bool> &seen) {",
			"        if(v == t) return flow;",
			"        seen[v] = true;",
			"        for(Edge &e : m_g[v]) {",
			"            if(e.cap > 0 and !seen[e.to]) {",
			"                T res = dfs(e.to, t, std::min(flow, e.cap), seen);",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    m_g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    FordFulkerson() : FordFulkerson(0) {}",
			"    explicit FordFulkerson(size_t vn) : m_g(vn) {}",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量capの有向辺を追加する．",
			"    int add_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, idx_to);",
			"        m_g[to].emplace_back(from, 0, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ノードsからtへの最大流を求める．O(F*|E|).",
			"    T max_flow(int s, int t) { return max_flow(s, t, infinity()); }",
			"    T max_flow(int s, int t, T flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        T res = 0;",
			"        std::vector<bool> seen(order());  // seen[v]:=(DFSにおいてノードvを調べたか).",
			"        while(res < flow) {",
			"            std::fill(seen.begin(), seen.end(), false);",
			"            T tmp = dfs(s, t, flow - res, seen);",
			"            if(tmp == 0) break;",
			"            res += tmp;",
			"        }",
			"        return res;",
			"    }",
			"    // 辺の情報を返す．",
			"    std::tuple<int, int, T, T> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, flow).",
			"    }",
			"    // 最小カットにより，グラフ上のノードを分割する．",
			"    std::vector<bool> min_cut(int s) const {",
			"        assert(0 <= s and s < order());",
			"        std::vector<bool> res(order(), false);",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            if(res[v]) continue;",
			"            res[v] = true;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and !res[e.to]) que.push(e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Ford-Fulkerson Algorithm（最大流）"
	},
	"Heap": {
		"scope": "cpp",
		"prefix": "Heap",
		"body": [
			"// 二分ヒープ．",
			"template <typename T>",
			"class Heap {",
			"    using Comp = std::function<bool(const T &, const T &)>;",
			"",
			"    Comp m_comp;            // bool m_comp(T,T):=(比較演算子).",
			"    std::vector<T> m_tree;  // m_tree[]:=(二分木). 1-based index.",
			"",
			"    void shift_up(int k) {",
			"        while(true) {",
			"            if(k == 1) break;",
			"            int par = k >> 1;",
			"            if(m_comp(m_tree[par], m_tree[k])) break;",
			"            std::swap(m_tree[par], m_tree[k]);",
			"            k = par;",
			"        }",
			"    }",
			"    void shift_down(int k) {",
			"        while(true) {",
			"            int l = k << 1, r = k << 1 | 1;",
			"            if(size() < l) break;",
			"            if(size() < r or m_comp(m_tree[l], m_tree[r])) {",
			"                if(m_comp(m_tree[k], m_tree[l])) break;",
			"                std::swap(m_tree[k], m_tree[l]);",
			"                k = l;",
			"            } else {",
			"                if(m_comp(m_tree[k], m_tree[r])) break;",
			"                std::swap(m_tree[k], m_tree[r]);",
			"                k = r;",
			"            }",
			"        }",
			"    }",
			"    void heap_sort() {",
			"        for(int i = 2; i <= size(); ++i) shift_up(i);",
			"    }",
			"",
			"public:",
			"    // constructor. O(N*logN).",
			"    Heap() : Heap([](const T &a, const T &b) -> bool { return a > b; }, std::vector<T>(0)) {}",
			"    explicit Heap(const Comp &comp) : Heap(comp, std::vector<T>(0)) {}",
			"    explicit Heap(const std::vector<T> &v) : Heap([](const T &a, const T &b) -> bool { return a > b; }, v) {}",
			"    explicit Heap(const Comp &comp, const std::vector<T> &v) : m_comp(comp), m_tree(v.size() + 1) {",
			"        if(size() > 0) {",
			"            std::copy(v.begin(), v.end(), m_tree.begin() + 1);",
			"            heap_sort();",
			"        }",
			"    }",
			"    ~Heap() {",
			"        std::vector<T>().swap(m_tree);",
			"    }",
			"",
			"    // 要素が空か判定する．O(1).",
			"    bool empty() const { return size() == 0; }",
			"    // 要素数を返す．O(1).",
			"    int size() const { return m_tree.size() - 1; }",
			"    // 要素参照．O(1).",
			"    T top() const {",
			"        assert(!empty());",
			"        return m_tree[1];",
			"    }",
			"    // 要素追加．O(logN).",
			"    void push(const T &a) {",
			"        m_tree.push_back(a);",
			"        shift_up(size());",
			"    }",
			"    // 要素削除．O(logN).",
			"    void pop() {",
			"        assert(!empty());",
			"        m_tree[1] = m_tree[size()];",
			"        m_tree.pop_back();",
			"        if(!empty()) shift_down(1);",
			"    }",
			"    // ヒープソート．O(N*logN).",
			"    void heap_sort(const Comp &comp) {",
			"        m_comp = comp;",
			"        heap_sort();",
			"    }",
			"};"
		],
		"description": "二分ヒープ"
	},
	"Imos2D": {
		"scope": "cpp",
		"prefix": "Imos2D",
		"body": [
			"// 二次元いもす法．",
			"template <typename T>",
			"class Imos2D {",
			"    int m_h, m_w;",
			"    std::vector<std::vector<T> > m_dat;  // 0-based index.",
			"",
			"public:",
			"    Imos2D() : Imos2D(0, 0) {}",
			"    explicit Imos2D(size_t h, size_t w) : m_h(h), m_w(w), m_dat(h + 1, std::vector<T>(w + 1, 0)) {}",
			"",
			"    int height() const { return m_h; }",
			"    int width() const { return m_w; }",
			"    void add(int ly, int lx, int ry, int rx, T val) {",
			"        assert(0 <= ly and ly <= ry and ry <= height());",
			"        assert(0 <= lx and lx <= rx and rx <= width());",
			"        m_dat[ly][lx] += val;",
			"        m_dat[ly][rx] -= val;",
			"        m_dat[ry][lx] -= val;",
			"        m_dat[ry][rx] += val;",
			"    }",
			"    void build() {",
			"        for(int i = 0; i < height(); ++i) {",
			"            for(int j = 0; j < width(); ++j) m_dat[i][j + 1] += m_dat[i][j];",
			"        }",
			"        for(int j = 0; j < width(); ++j) {",
			"            for(int i = 0; i < height(); ++i) m_dat[i + 1][j] += m_dat[i][j];",
			"        }",
			"    }",
			"    T get(int y, int x) const {",
			"        assert(0 <= y and y < height());",
			"        assert(0 <= x and x < width());",
			"        return m_dat[y][x];",
			"    }",
			"    void reset() {",
			"        for(std::vector<T> &v : m_dat) std::fill(v.begin(), v.end(), 0);",
			"    }",
			"};"
		],
		"description": "二次元いもす法"
	},
	"Kitamasa": {
		"scope": "cpp",
		"prefix": "Kitamasa",
		"body": [
			"// きたまさ法．",
			"// 線形漸化式 a[n]=d[0]*a[n-k]+d[1]*a[n-(k-1)]+....+d[k-1]*a[n-1] を求める．O((K^2)*logN).",
			"template <typename T = long long>",
			"class Kitamasa {",
			"public:",
			"    using size_type = uint64_t;",
			"",
			"private:",
			"    size_type m_k;       // m_k:=(階数).",
			"    std::vector<T> m_a;  // m_a[]:=(初項行列).",
			"    std::vector<T> m_d;  // m_d[]:=(係数行列).",
			"",
			"    // f(n)->f(n+1). O(K).",
			"    std::vector<T> add(const std::vector<T> &x) const {",
			"        std::vector<T> y(m_k);",
			"        y[0] = x[m_k - 1] * m_d[0];",
			"        for(size_type i = 1; i < m_k; ++i) y[i] = x[i - 1] + x[m_k - 1] * m_d[i];",
			"        return y;",
			"    }",
			"    // f(n)->f(2*n). O(K^2).",
			"    std::vector<T> mul(const std::vector<T> &x) const {",
			"        std::vector<T> y(m_k, 0);",
			"        std::vector<T> t = x;",
			"        for(size_type i = 0; i < m_k; ++i) {",
			"            for(size_type j = 0; j < m_k; ++j) y[j] += x[i] * t[j];",
			"            if(i < m_k - 1) t = add(t);",
			"        }",
			"        return y;",
			"    }",
			"    // f(n)を返す．O((K^2)*logN).",
			"    std::vector<T> f(size_type n) const {",
			"        if(n == 0) {",
			"            std::vector<T> x(m_k, 0);",
			"            x[0] = 1;",
			"            return x;  // f(0).",
			"        }",
			"        std::vector<T> &&x = mul(f(n / 2));",
			"        if(n & 1ULL) x = add(x);",
			"        return x;",
			"    }",
			"",
			"public:",
			"    Kitamasa() : Kitamasa(std::vector<T>({0, 1}), std::vector<T>({1, 1})) {}  // フィボナッチ数列．",
			"    explicit Kitamasa(const std::vector<T> &a, const std::vector<T> &d) : m_k(a.size()), m_a(a), m_d(d) {",
			"        assert(a.size() >= 1);",
			"        assert(a.size() == d.size());",
			"    }",
			"",
			"    T operator[](size_type n) const { return calc(n); }",
			"",
			"    // a[n]を求める．O((K^2)*logN).",
			"    T calc(size_type n) const {",
			"        const std::vector<T> &&x = f(n);",
			"        T res = 0;",
			"        for(size_type i = 0; i < m_k; ++i) res += x[i] * m_a[i];",
			"        return res;",
			"    }",
			"};"
		],
		"description": "きたまさ法"
	},
	"LCA": {
		"scope": "cpp",
		"prefix": "LCA",
		"body": [
			"// Lowest Common Ancestor（最近共通祖先）.",
			"template <typename T = int>  // T:Type of cost.",
			"class LCA {",
			"    int m_vn;                                           // m_vn:=(ノード数).",
			"    int m_lb;                                           // m_lb:=ceiling(log2(vn)).",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost). グラフは木であること．",
			"    std::vector<std::vector<int> > m_par;               // m_par[k][v]:=(ノードvから2^k回辿って到達する親ノード番号). 親がいない場合は-1．",
			"    std::vector<int> m_depth;                           // m_depth[v]:=(ノードvの深さ). 根に連結していない場合は-1．",
			"    std::vector<T> m_dist;                              // m_dist[v]:=(根からノードvまでの距離).",
			"    std::vector<int> m_ord;                             // m_ord[v]:=(DFS木におけるノードvの行きかけ順序).",
			"",
			"    bool is_unconnected(int v) const { return m_ord[v] == -1; }",
			"    void dfs(int u, int p, int depth, T distance, int &now) {",
			"        assert(m_ord[u] == -1);  // グラフ上に閉路はないこと．",
			"        m_ord[u] = now++;",
			"        m_par[0][u] = p;",
			"        m_depth[u] = depth;",
			"        m_dist[u] = distance;",
			"        for(const auto &[v, cost] : m_g[u]) {",
			"            if(v == p) continue;",
			"            dfs(v, u, depth + 1, distance + cost, now);",
			"        }",
			"    }",
			"",
			"public:",
			"    LCA() : LCA(0) {}",
			"    explicit LCA(size_t vn) : m_vn(vn), m_lb(1), m_g(vn), m_depth(vn, -1), m_dist(vn, infinity()), m_ord(vn, -1) {",
			"        while(1 << m_lb < order()) m_lb++;",
			"        m_par.assign(m_lb, std::vector<int>(order(), -1));",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 無向辺を張る．ノードuとvは非連結であること．",
			"    void add_edge(int u, int v, T cost = 0) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].emplace_back(v, cost);",
			"        m_g[v].emplace_back(u, cost);",
			"    }",
			"    // 祖先木を構築する．O(|V|*log|V|).",
			"    void build(int rt = 0) {",
			"        assert(0 <= rt and rt < order());",
			"        for(std::vector<int> &v : m_par) std::fill(v.begin(), v.end(), -1);",
			"        std::fill(m_depth.begin(), m_depth.end(), -1);",
			"        std::fill(m_dist.begin(), m_dist.end(), infinity());",
			"        std::fill(m_ord.begin(), m_ord.end(), -1);",
			"        int now = 0;",
			"        dfs(rt, -1, 0, 0, now);",
			"        for(int k = 0; k < m_lb - 1; ++k) {",
			"            for(int v = 0; v < order(); ++v) {",
			"                if(m_par[k][v] != -1) m_par[k + 1][v] = m_par[k][m_par[k][v]];",
			"            }",
			"        }",
			"    }",
			"    // ノードvの祖先をk代遡る．O(log|V|).",
			"    int trace_back(int v, int k) const {",
			"        assert(0 <= v and v < order());",
			"        assert(0 <= k and k < order());",
			"        if(k > m_depth[v]) return -1;",
			"        for(int i = 0; i < m_lb; ++i) {",
			"            if(k >> i & 1) v = m_par[i][v];",
			"        }",
			"        return v;",
			"    }",
			"    // 木上のノードuとvの最も近い共通の祖先を求める．O(log|V|).",
			"    int lca(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        if(is_unconnected(u) or is_unconnected(v)) return -1;",
			"        if(m_depth[u] > m_depth[v]) std::swap(u, v);",
			"        v = trace_back(v, m_depth[v] - m_depth[u]);  // 同じ深さに合わせる．",
			"        if(u == v) return u;",
			"        for(int k = m_lb - 1; k >= 0; --k) {",
			"            if(m_par[k][u] != m_par[k][v]) u = m_par[k][u], v = m_par[k][v];  // 異なったら根に近づける．",
			"        }",
			"        return m_par[0][u];",
			"    }",
			"    // ノードvの深さを返す．O(1).",
			"    T depth(int v) const {",
			"        assert(0 <= v and v < order());",
			"        return m_depth[v];",
			"    }",
			"    // ノードu, v間の長さを求める．O(log|V|).",
			"    int length(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        if(is_unconnected(u) or is_unconnected(v)) return -1;",
			"        return m_depth[u] + m_depth[v] - 2 * m_depth[lca(u, v)];",
			"    }",
			"    // 根とノードv間の距離を返す．O(1).",
			"    T distance(int v) const {",
			"        assert(0 <= v and v < order());",
			"        return m_dist[v];",
			"    }",
			"    // ノードu, v間の距離を求める．O(log|V|).",
			"    T distance(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        if(is_unconnected(u) or is_unconnected(v)) return infinity();",
			"        return m_dist[u] + m_dist[v] - 2 * m_dist[lca(u, v)];",
			"    }",
			"    // 木の圧縮．",
			"    // 任意の頂点集合とそのLCAからなる，頂点同士の関係性を維持した木を作成する．O(K*log|V|).",
			"    std::pair<int, std::map<int, std::vector<int> > > auxiliary_tree(std::vector<int> &vs) const {",
			"        assert(std::find_if(vs.begin(), vs.end(), [&](int v) -> bool { return !(0 <= v and v < order()); }) == vs.end());",
			"        std::map<int, std::vector<int> > res;  // res[v][]:=(圧縮した木におけるノードvの隣接リスト).",
			"        vs.erase(std::remove_if(vs.begin(), vs.end(), [&](int v) -> bool { return is_unconnected(v); }), vs.end());",
			"        auto comp = [&](int u, int v) -> bool { return m_ord[u] < m_ord[v]; };",
			"        std::sort(vs.begin(), vs.end(), comp);",
			"        vs.erase(std::unique(vs.begin(), vs.end()), vs.end());",
			"        const int n = vs.size();",
			"        if(n == 0) return {-1, res};",
			"        if(n == 1) {",
			"            res[vs[0]];",
			"            return {vs[0], res};",
			"        }",
			"        std::stack<int> st;",
			"        st.push(vs[0]);",
			"        for(int i = 1; i < n; ++i) {",
			"            int w = lca(vs[i - 1], vs[i]);",
			"            if(w != vs[i - 1]) {",
			"                int v = st.top();",
			"                st.pop();",
			"                while(!st.empty() and m_depth[st.top()] > m_depth[w]) {",
			"                    res[st.top()].push_back(v);",
			"                    res[v].push_back(st.top());",
			"                    v = st.top();",
			"                    st.pop();",
			"                }",
			"                if(st.empty() or st.top() != w) {",
			"                    st.push(w);",
			"                    vs.push_back(w);",
			"                }",
			"                res[w].push_back(v);",
			"                res[v].push_back(w);",
			"            }",
			"            st.push(vs[i]);",
			"        }",
			"        while(st.size() > 1) {",
			"            int v = st.top();",
			"            st.pop();",
			"            res[st.top()].push_back(v);",
			"            res[v].push_back(st.top());",
			"        }",
			"        std::sort(vs.begin(), vs.end(), comp);",
			"        return {st.top(), res};  // pair of (root, tree).",
			"    }",
			"};"
		],
		"description": "Lowest Common Ancestor（最近共通祖先）"
	},
	"LazySegTree": {
		"scope": "cpp",
		"prefix": "LazySegTree",
		"body": [
			"// Lazy Segment Tree（遅延評価セグメント木）.",
			"template <class S, class F>  // S:モノイドの型, F:写像の型.",
			"class LazySegTree {",
			"    using Op = std::function<S(const S &, const S &)>;",
			"    using Mapping = std::function<S(const F &, const S &)>;",
			"    using Composition = std::function<F(const F &, const F &)>;",
			"",
			"    Op m_op;                    // S m_op(S,S):=(二項演算関数). S×S→Sを計算する．",
			"    Mapping m_mapping;          // S m_mapping(F f,S x):=(写像). f(x)を返す．",
			"    Composition m_composition;  // F m_composition(F f,F g):=(写像の合成). f∘gを返す．",
			"    S m_e;                      // m_e:=(単位元).",
			"    F m_id;                     // m_id:=(恒等写像).",
			"    int m_sz;                   // m_sz:=(要素数).",
			"    int m_n;                    // m_n:=(二分木の葉数).",
			"    int m_depth;                // m_depth:=(二分木の深さ).",
			"    std::vector<S> m_tree;      // m_tree(2n)[]:=(完全二分木). 1-based index.",
			"    std::vector<F> m_lazy;      // m_lazy(n)[k]:=(m_tree[k]の子 (m_tree[2k], m_tree[2k+1]) に対する遅延評価).",
			"",
			"    void apply0(int k, const F &f) {",
			"        assert(1 <= k and k < 2 * m_n);",
			"        m_tree[k] = m_mapping(f, m_tree[k]);",
			"        if(k < m_n) m_lazy[k] = m_composition(f, m_lazy[k]);",
			"    }",
			"    void push(int k) {",
			"        assert(1 <= k and k < m_n);",
			"        apply0(k << 1, m_lazy[k]);",
			"        apply0(k << 1 | 1, m_lazy[k]);",
			"        m_lazy[k] = identity_mapping();",
			"    }",
			"    void update(int k) {",
			"        assert(1 <= k and k < m_n);",
			"        m_tree[k] = m_op(m_tree[k << 1], m_tree[k << 1 | 1]);",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    LazySegTree() {}",
			"    explicit LazySegTree(const Op &op, const Mapping &mapping, const Composition &composition, const S &e, const F &id, size_t n)",
			"        : m_op(op), m_mapping(mapping), m_composition(composition), m_e(e), m_id(id), m_sz(n), m_n(1), m_depth(0) {",
			"        while(m_n < size()) m_n <<= 1, m_depth++;",
			"        m_tree.assign(2 * m_n, identity());",
			"        m_lazy.assign(m_n, identity_mapping());",
			"    }",
			"    explicit LazySegTree(const Op &op, const Mapping &mapping, const Composition &composition, const S &e, const F &id, const std::vector<S> &v)",
			"        : LazySegTree(op, mapping, composition, e, id, v.size()) {",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + m_n);",
			"        for(int i = m_n - 1; i >= 1; --i) update(i);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // モノイドの単位元を返す．",
			"    S identity() const { return m_e; }",
			"    // 恒等写像を返す．",
			"    F identity_mapping() const { return m_id; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const S &a) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        m_tree[k] = a;",
			"        for(int i = 1; i <= m_depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,-)の要素をv[]に置き換える．O(N).",
			"    void set(int l, const std::vector<S> &v) {",
			"        assert(0 <= l and l + (int)v.size() <= size());",
			"        if(v.size() == 0) return;",
			"        l += m_n;",
			"        int r = l + (int)v.size();",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            for(int j = l >> i, end = (r - 1) >> i; j <= end; ++j) push(j);",
			"        }",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + l);",
			"        for(int i = 1; i <= m_depth; ++i) {",
			"            for(int j = l >> i, end = (r - 1) >> i; j <= end; ++j) update(j);",
			"        }",
			"    }",
			"    // k番目の要素を写像fを用いて更新する．O(logN).",
			"    void apply(int k, const F &f) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        m_tree[k] = m_mapping(f, m_tree[k]);",
			"        for(int i = 1; i <= m_depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,r)の要素を写像fを用いて更新する．O(logN).",
			"    void apply(int l, int r, const F &f) {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        if(l == r) return;",
			"        l += m_n, r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            if((l >> i) << i != l) push(l >> i);",
			"            if((r >> i) << i != r) push((r - 1) >> i);",
			"        }",
			"        for(int l2 = l, r2 = r; l2 < r2; l2 >>= 1, r2 >>= 1) {",
			"            if(l2 & 1) apply0(l2++, f);",
			"            if(r2 & 1) apply0(--r2, f);",
			"        }",
			"        for(int i = 1; i <= m_depth; ++i) {",
			"            if((l >> i) << i != l) update(l >> i);",
			"            if((r >> i) << i != r) update((r - 1) >> i);",
			"        }",
			"    }",
			"    // k番目の要素を求める．O(logN).",
			"    S prod(int k) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        return m_tree[k];",
			"    }",
			"    // 区間[l,r)の要素の総積 v[l]•v[l+1]•....•v[r-1] を求める．O(logN).",
			"    S prod(int l, int r) {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        if(l == r) return identity();",
			"        l += m_n, r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            if((l >> i) << i != l) push(l >> i);",
			"            if((r >> i) << i != r) push((r - 1) >> i);",
			"        }",
			"        S val_l = identity(), val_r = identity();",
			"        for(; l < r; l >>= 1, r >>= 1) {",
			"            if(l & 1) val_l = m_op(val_l, m_tree[l++]);",
			"            if(r & 1) val_r = m_op(m_tree[--r], val_r);",
			"        }",
			"        return m_op(val_l, val_r);",
			"    }",
			"    // 区間全体の要素の総積を返す．O(1).",
			"    S prod_all() const { return m_tree[1]; }",
			"    // jud(prod(l,-))=true となる区間の最右位値を二分探索する．",
			"    // ただし要素列には単調性があり，また jud(e)=true であること．O(logN).",
			"    int most_right(const std::function<bool(const S &)> &jud, int l) const {",
			"        assert(jud(identity()));",
			"        assert(0 <= l and l <= size());",
			"        if(l == size()) return size();",
			"        l += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(l >> i);",
			"        S val = identity();",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            S &&tmp = m_op(val, m_tree[l]);",
			"            if(!jud(tmp)) {",
			"                while(l < m_n) {",
			"                    push(l);",
			"                    l <<= 1;",
			"                    S &&tmp2 = m_op(val, m_tree[l]);",
			"                    if(jud(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - m_n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return size();",
			"    }",
			"    // jud(prod(-,r))=true となる区間の最左位値を二分探索する．",
			"    // ただし要素列には単調性があり，また jud(e)=true であること．O(logN).",
			"    int most_left(const std::function<bool(const S &)> &jud, int r) const {",
			"        assert(jud(identity()));",
			"        assert(0 <= r and r <= size());",
			"        if(r == 0) return 0;",
			"        r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push((r - 1) >> i);",
			"        S val = identity();",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            S &&tmp = m_op(m_tree[r], val);",
			"            if(!jud(tmp)) {",
			"                while(r < m_n) {",
			"                    push(r);",
			"                    r = r << 1 | 1;",
			"                    S &&tmp2 = m_op(m_tree[r], val);",
			"                    if(jud(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - m_n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() {",
			"        std::fill(m_tree.begin(), m_tree.end(), identity());",
			"        std::fill(m_lazy.begin(), m_lazy.end(), identity_mapping());",
			"    }",
			"};"
		],
		"description": "Lazy Segment Tree（遅延評価セグメント木）"
	},
	"LinearSieve": {
		"scope": "cpp",
		"prefix": "LinearSieve",
		"body": [
			"// 線形篩．",
			"class LinearSieve {",
			"    int m_mx;                   // m_mx:=(篩にかける最大の自然数).",
			"    std::vector<int> m_lpf;     // m_lpf[n]:=(自然数nの最小の素因数). Least prime factor. m_lpf[n]==n のとき，nは素数．",
			"    std::vector<int> m_primes;  // m_primes[]:=(自然数n以下の素数のリスト).",
			"",
			"public:",
			"    // constructor. n以下の自然数を篩にかける．O(N).",
			"    LinearSieve() : LinearSieve(51e4) {}",
			"    explicit LinearSieve(int n) : m_mx(n), m_lpf(n + 1, -1) {",
			"        assert(n >= 0);",
			"        for(int p = 2; p <= m_mx; ++p) {",
			"            if(m_lpf[p] == -1) {",
			"                m_lpf[p] = p;",
			"                m_primes.push_back(p);",
			"            }",
			"            for(int prime : m_primes) {",
			"                if(prime * p > m_mx or prime > m_lpf[p]) break;",
			"                m_lpf[prime * p] = prime;",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小の素因数を返す．O(1).",
			"    int lpf(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const std::map<int, int> &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    // 素数のリストを参照する．O(1).",
			"    const std::vector<int> &primes() const { return m_primes; }",
			"};"
		],
		"description": "線形篩"
	},
	"LowLink": {
		"scope": "cpp",
		"prefix": "LowLink",
		"body": [
			"class LowLink {",
			"    std::vector<std::vector<int> > m_g;       // m_g[v][]:=(頂点vの隣接リスト).",
			"    std::vector<int> m_aps;                   // m_aps[]:=(関節点のリスト). Articulation points.",
			"    std::vector<std::pair<int, int> > m_brs;  // m_brs[]:=(橋のリスト). Bridges.",
			"",
			"    void dfs(int u, int parent, std::vector<int> &ord, std::vector<int> &low, int &now) {",
			"        ord[u] = low[u] = now++;",
			"        int degree = 0;      // degree:=(DFS木での頂点uにおける葉方向への出次数).",
			"        bool is_ap = false;  // is_ap:=(頂点uが関節点か).",
			"        for(int v : m_g[u]) {",
			"            if(v == parent) continue;",
			"            if(ord[v] == -1) {  // 頂点vが未訪問のとき．",
			"                degree++;",
			"                dfs(v, u, ord, low, now);",
			"                low[u] = std::min(low[u], low[v]);",
			"                if(ord[u] < low[v]) {  // 辺(u,v)が橋のとき．",
			"                    if(u < v) m_brs.emplace_back(u, v);",
			"                    else m_brs.emplace_back(v, u);",
			"                }",
			"                if(parent != -1 and ord[u] <= low[v]) is_ap = true;  // 根以外で関節点のとき．",
			"            } else {                                                 // 辺(u,v)が後退辺のとき．",
			"                low[u] = std::min(low[u], ord[v]);",
			"            }",
			"        }",
			"        if(parent == -1 and degree > 1) is_ap = true;  // 根が関節点のとき．",
			"        if(is_ap) m_aps.push_back(u);",
			"    }",
			"",
			"public:",
			"    LowLink() : LowLink(0) {}",
			"    explicit LowLink(size_t vn) : m_g(vn) {}",
			"",
			"    // 頂点数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 無向辺を張る．",
			"    void add_edge(int u, int v) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].push_back(v);",
			"        m_g[v].push_back(u);",
			"    }",
			"    // 無向グラフの橋と関節点を求める．O(|V|+|E|).",
			"    void lowlink() {",
			"        m_aps.clear();",
			"        m_brs.clear();",
			"        // ord[v]:=(DFS木における頂点vの行きかけ順序).",
			"        // low[v]:=(DFS木において，頂点vから葉方向に0回以上，後退辺を高々1回用いて到達できる頂点wのord[w]の最小値).",
			"        std::vector<int> ord(order(), -1), low(order());",
			"        int now = 0;",
			"        for(int v = 0, n = order(); v < n; ++v) {",
			"            if(ord[v] == -1) dfs(v, -1, ord, low, now);",
			"        }",
			"        std::sort(m_aps.begin(), m_aps.end());",
			"        std::sort(m_brs.begin(), m_brs.end());",
			"    }",
			"    // 関節点のリストを参照する．",
			"    const std::vector<int> &articulation_points() const { return m_aps; }",
			"    // 橋のリストを参照する．",
			"    const std::vector<std::pair<int, int> > &bridges() const { return m_brs; }",
			"};"
		],
		"description": "Low-Link（橋，関節点）"
	},
	"Manacher": {
		"scope": "cpp",
		"prefix": "Manacher",
		"body": [
			"// Longest Palindromic Substring（最長回文）.",
			"template <class Sequence>",
			"class Manacher {",
			"    int m_sz;  // m_sz:=(配列サイズ).",
			"    // m_radius[2*k]:=(k文字目を中心とする奇数長の最長回文の半径),",
			"    // m_radius[2*k+1]:=(k文字目とk+1文字目の間を中心とする偶数長の最長回文の半径).",
			"    std::vector<int> m_radius;",
			"",
			"public:",
			"    // constructor. 引数はSTLのシーケンスコンテナ．O(|S|).",
			"    Manacher() : Manacher(Sequence()) {}",
			"    explicit Manacher(const Sequence &s) : m_sz(s.size()), m_radius(2 * s.size(), 0) {",
			"        if(size() == 0) return;",
			"        const int n = 2 * size() - 1;",
			"        Sequence t(n, 0);",
			"        for(int i = 0; i < size(); ++i) t[2 * i] = s[i];",
			"        int i = 0, j = 0;",
			"        while(i < n) {",
			"            while(0 <= i - j and i + j < n and t[i - j] == t[i + j]) j++;",
			"            m_radius[i] = j;",
			"            int k = 1;",
			"            while(i - k >= 0 and k + m_radius[i - k] < j) {",
			"                m_radius[i + k] = m_radius[i - k];",
			"                k++;",
			"            }",
			"            i += k, j -= k;",
			"        }",
			"    }",
			"",
			"    // 配列のサイズを返す．",
			"    int size() const { return m_sz; }",
			"    // k文字目を中心とする奇数長の最長回文の半径を返す．",
			"    int odd_radius(int k) const {",
			"        assert(0 <= k and k < size());",
			"        return (m_radius[2 * k] + 1) / 2;",
			"    }",
			"    // k文字目とk+1文字目の間を中心とする偶数長の最長回文の半径を返す．",
			"    int even_radius(int k) const {",
			"        assert(0 <= k and k < size() - 1);",
			"        return m_radius[2 * k + 1] / 2;",
			"    }",
			"    // 部分列s[l:r]が回文か判定する．",
			"    bool is_palindrome(int l, int r) const {",
			"        assert(0 <= l and l < r and r <= size());",
			"        int mid = (l + r) / 2;",
			"        if(r - l & 1) return odd_radius(mid) >= (r - l + 1) / 2;",
			"        return even_radius(mid - 1) >= (r - l) / 2;",
			"    }",
			"};"
		],
		"description": "Longest Palindromic Substring（最長回文）"
	},
	"Mo": {
		"scope": "cpp",
		"prefix": "Mo",
		"body": [
			"// Mo's Algorithm（クエリ平方分割）.",
			"class Mo {",
			"    int m_len;                                          // m_len:=(区間の長さ).",
			"    int m_q;                                            // m_q:=(クエリ数).",
			"    std::vector<std::tuple<int, int, int> > m_queries;  // m_queries[i]:=(i番目の区間クエリ). tuple of (left, right, index).",
			"",
			"    void sort_query() {",
			"        const int width = std::sqrt(m_len);",
			"        auto comp = [&width](const std::tuple<int, int, int> &a, const std::tuple<int, int, int> &b) -> bool {",
			"            const auto &[al, ar, _] = a;",
			"            const auto &[bl, br, __] = b;",
			"            int a_block = al / width, b_block = bl / width;",
			"            if(a_block == b_block) return (a_block & 1 ? ar > br : ar < br);",
			"            return a_block < b_block;",
			"        };",
			"        std::sort(m_queries.begin(), m_queries.end(), comp);",
			"    }",
			"",
			"public:",
			"    Mo() : Mo(0) {}",
			"    explicit Mo(size_t n) : m_len(n), m_q(0) {}",
			"",
			"    // 区間[l,r)のクエリを追加する．",
			"    void insert(int l, int r) {",
			"        assert(0 <= l and l < r and r <= m_len);",
			"        m_queries.emplace_back(l, r, m_q++);",
			"    }",
			"    // 各クエリを実行する．引数はラムダ式．O(α(N+Q)√N).",
			"    template <typename F1, typename F2, typename F3>",
			"    void execute(const F1 &add, const F2 &del, const F3 &solve) { execute(add, del, add, del, solve); }",
			"    template <typename F1, typename F2, typename F3, typename F4, typename F5>",
			"    void execute(const F1 &add_l, const F2 &del_l, const F3 &add_r, const F4 &del_r, const F5 &solve) {",
			"        sort_query();",
			"        int l = 0, r = 0;",
			"        for(const auto &[nl, nr, idx] : m_queries) {",
			"            while(nl < l) add_l(--l);",
			"            while(r < nr) add_r(r++);",
			"            while(l < nl) del_l(l++);",
			"            while(nr < r) del_r(--r);",
			"            solve(idx);",
			"        }",
			"    }",
			"    void reset() {",
			"        m_queries.clear();",
			"        m_q = 0;",
			"    }",
			"};"
		],
		"description": "Mo's Algorithm（クエリ平方分割）"
	},
	"Modint": {
		"scope": "cpp",
		"prefix": "Modint",
		"body": [
			"class ModintBase {};",
			"",
			"template <class T>",
			"using is_modint = std::is_base_of<ModintBase, T>;",
			"",
			"template <class T>",
			"inline constexpr bool is_modint_v = is_modint<T>::value;",
			"",
			"template <int mod>",
			"class Modint : ModintBase {",
			"    long long val;",
			"",
			"    void normalize() {",
			"        if(!(-mod <= val and val < mod)) val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"public:",
			"    Modint() : Modint(0) {}",
			"    Modint(long long val_) : val(val_) {",
			"        static_assert(mod >= 1);",
			"        normalize();",
			"    }",
			"",
			"    Modint operator+() const { return Modint(*this); }",
			"    Modint operator-() const { return (val == 0 ? Modint(*this) : Modint(mod - val)); }",
			"    Modint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    Modint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    Modint operator++(int) {",
			"        Modint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    Modint operator--(int) {",
			"        Modint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    Modint &operator+=(const Modint &rhs) {",
			"        val += rhs.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    Modint &operator-=(const Modint &rhs) {",
			"        val -= rhs.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    Modint &operator*=(const Modint &rhs) {",
			"        val = val * rhs.val % mod;",
			"        return *this;",
			"    }",
			"    Modint &operator/=(const Modint &rhs) { return *this *= rhs.inv(); }",
			"",
			"    friend Modint operator+(const Modint &lhs, const Modint &rhs) { return Modint(lhs) += rhs; }",
			"    friend Modint operator-(const Modint &lhs, const Modint &rhs) { return Modint(lhs) -= rhs; }",
			"    friend Modint operator*(const Modint &lhs, const Modint &rhs) { return Modint(lhs) *= rhs; }",
			"    friend Modint operator/(const Modint &lhs, const Modint &rhs) { return Modint(lhs) /= rhs; }",
			"    friend bool operator==(const Modint &lhs, const Modint &rhs) { return lhs.val == rhs.val; }",
			"    friend bool operator!=(const Modint &lhs, const Modint &rhs) { return lhs.val != rhs.val; }",
			"    friend std::istream &operator>>(std::istream &is, Modint &rhs) {",
			"        is >> rhs.val;",
			"        rhs.normalize();",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Modint &rhs) { return os << rhs.val; }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    Modint inv() const {",
			"        long long a = val, b = mod, u = 1, v = 0;",
			"        while(b != 0) {",
			"            long long t = a / b;",
			"            a -= b * t, u -= v * t;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return Modint(u);",
			"    }",
			"    Modint pow(long long k) const {",
			"        if(k < 0) return inv().pow(-k);",
			"        Modint res = 1, mul = *this;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= mul;",
			"            mul *= mul;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend Modint mod_inv(const Modint &a) { return a.inv(); }",
			"    friend Modint mod_pow(const Modint &a, long long k) { return a.pow(k); }",
			"};",
			"",
			"using mint998244353 = Modint<998'244'353>;",
			"using mint1000000007 = Modint<1'000'000'007>;"
		],
		"description": "Modint構造体"
	},
	"ModintBase": {
		"scope": "cpp",
		"prefix": "ModintBase",
		"body": [
			"class ModintBase {};",
			"",
			"template <class T>",
			"using is_modint = std::is_base_of<ModintBase, T>;",
			"",
			"template <class T>",
			"inline constexpr bool is_modint_v = is_modint<T>::value;"
		],
		"description": "Modint構造体の基底クラス"
	},
	"Montmort": {
		"scope": "cpp",
		"prefix": "Montmort",
		"body": [
			"// 完全順列（mod付き）．",
			"template <int mod>",
			"class Montmort {",
			"    int m_sz;",
			"    std::vector<long long> m_montmort;  // m_montmort[k]:=(k番目のモンモール数).",
			"",
			"public:",
			"    Montmort() : Montmort(51e4) {}",
			"    explicit Montmort(size_t sz) : m_sz(sz), m_montmort(sz) {",
			"        static_assert(mod >= 1);",
			"        assert(m_sz >= 2);",
			"        m_montmort[0] = 1, m_montmort[1] = 0;",
			"        for(int i = 2; i < m_sz; ++i) m_montmort[i] = (i - 1) * ((m_montmort[i - 2] + m_montmort[i - 1]) % mod) % mod;  // 隣接三項間の漸化式．",
			"        // for(int i = 2; i < m_sz; ++i) m_montmort[i] = (i * m_montmort[i - 1] % mod + (i & 1 ? -1 : 1) + mod) % mod;  // 隣接二項間の漸化式．",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // k個の要素を並び替えたときに完全順列となる通り数．",
			"    long long montmort(int k) const {",
			"        assert(1 <= k and k < m_sz);",
			"        return m_montmort[k];",
			"    }",
			"    // 無限個の要素を並び替えたときに完全順列となる確率．",
			"    static constexpr double converged_probability() { return 1.0 / std::exp(1.0); }",
			"};"
		],
		"description": "完全順列（mod付き）"
	},
	"PartiallyPersistentUnionFind": {
		"scope": "cpp",
		"prefix": "PartiallyPersistentUnionFind",
		"body": [
			"// 部分永続Union-Find．",
			"class PartiallyPersistentUnionFind {",
			"    using pii = std::pair<int, int>;",
			"",
			"    int m_now;  // m_now:=(現在時刻).",
			"    int m_vn;   // m_vn:=(要素数).",
			"    int m_gn;   // m_gn:=(グループ数).",
			"    // m_par[x][](t,id):=(要素xにおける更新時間tと親番号id).",
			"    // 値idが0未満の場合，xは根であり，値idの絶対値は属するグループのサイズを表す．",
			"    std::vector<std::vector<pii> > m_par;",
			"",
			"    static constexpr int infinity() { return std::numeric_limits<int>::max(); }",
			"",
			"public:",
			"    PartiallyPersistentUnionFind() : PartiallyPersistentUnionFind(0) {}",
			"    explicit PartiallyPersistentUnionFind(size_t vn)",
			"        : m_now(0), m_vn(vn), m_gn(vn), m_par(vn, std::vector<pii>({{0, -1}})) {}",
			"",
			"    // 現在の時刻を返す．",
			"    int now() const { return m_now; }",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 現在において要素xが属するグループ（根付き木）の根番号を返す．O(logN).",
			"    int root(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        while(m_par[x].crbegin()->second >= 0) x = m_par[x].crbegin()->second;",
			"        return x;",
			"    }",
			"    // 時刻tにおいて要素xが属するグループ（根付き木）の根番号を返す．O(logN).",
			"    int root(int x, int t) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= t and t <= now());",
			"        auto itr = std::lower_bound(m_par[x].cbegin(), m_par[x].cend(), pii(t, -infinity()));",
			"        if(itr == m_par[x].cend() or itr->first > t) itr--;",
			"        if(itr->second < 0) return x;",
			"        return root(itr->second, t);",
			"    }",
			"    // 現在において要素xが属するグループのサイズを返す．O(logN).",
			"    int size(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)].crbegin()->second;",
			"    }",
			"    // 時刻tにおいて要素xが属するグループのサイズを返す．O(logN).",
			"    int size(int x, int t) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= t and t <= now());",
			"        auto itr = std::lower_bound(m_par[x].cbegin(), m_par[x].cend(), pii(t, -infinity()));",
			"        if(itr == m_par[x].cend() or itr->first > t) itr--;",
			"        if(itr->second < 0) return -itr->second;",
			"        return size(itr->second, t);",
			"    }",
			"    // 現在において要素x, yが同じグループに属するか判定する．O(logN).",
			"    bool is_same(int x, int y) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 時刻tにおいて要素x, yが同じグループに属するか判定する．O(logN).",
			"    bool is_same(int x, int y, int t) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        assert(0 <= t and t <= now());",
			"        return root(x, t) == root(y, t);",
			"    }",
			"    // 要素xが属するグループと要素yが属するグループとを併合し，時間を+1進める．O(logN).",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        m_now++;",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;  // Already united.",
			"        int sz_x = -m_par[x].crbegin()->second;",
			"        int sz_y = -m_par[y].crbegin()->second;",
			"        if(sz_x < sz_y) std::swap(x, y);  // Merge technique (unite by size).",
			"        m_par[x].emplace_back(now(), -sz_x - sz_y);",
			"        m_par[y].emplace_back(now(), x);",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_now = 1;",
			"        m_gn = vn();",
			"        for(std::vector<pii> &history : m_par) history.resize(1);",
			"    }",
			"};"
		],
		"description": "部分永続Union-Find"
	},
	"PotentializedUnionFind": {
		"scope": "cpp",
		"prefix": "PotentializedUnionFind",
		"body": [
			"// 重み付きUnion-Find．",
			"template <typename T>",
			"class PotentializedUnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親番号). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"    std::vector<T> m_p;  // m_p[x]:=(要素xのポテンシャル).",
			"",
			"public:",
			"    PotentializedUnionFind() : PotentializedUnionFind(0) {}",
			"    explicit PotentializedUnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1), m_p(vn, 0) {}",
			"",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根番号を返す．O(α(N)).",
			"    int root(int x) {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        int tmp = root(m_par[x]);  // 経路圧縮．",
			"        m_p[x] += m_p[m_par[x]];",
			"        return m_par[x] = tmp;",
			"    }",
			"    // 要素xが属するグループのサイズを返す．",
			"    int size(int x) {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素xのポテンシャルを返す．",
			"    T potential(int x) {",
			"        assert(0 <= x and x < vn());",
			"        root(x);",
			"        return m_p[x];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．",
			"    bool is_same(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素xに対するyの相対ポテンシャルを返す．",
			"    T diff(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return potential(y) - potential(x);",
			"    }",
			"    // diff(x,y)==d となるように，要素xが属するグループと要素yが属するグループとを併合する．",
			"    bool unite(int x, int y, T d) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        d = d + potential(x) - potential(y);",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;     // Do nothing.",
			"        if(-m_par[x] < -m_par[y]) {  // Merge technique (union by size).",
			"            std::swap(x, y);",
			"            d = -d;",
			"        }",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_p[y] = d;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"        std::fill(m_p.begin(), m_p.end(), 0);",
			"    }",
			"};"
		],
		"description": "重み付きUnion-Find"
	},
	"Prim": {
		"scope": "cpp",
		"prefix": "Prim",
		"body": [
			"template <typename T>",
			"class Prim {",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost).",
			"",
			"public:",
			"    Prim() : Prim(0) {}",
			"    explicit Prim(size_t vn) : m_g(vn) {}",
			"",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 重み付き無向辺を張る．",
			"    void add_edge(int u, int v, T cost) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].emplace_back(v, cost);",
			"        m_g[v].emplace_back(u, cost);",
			"    }",
			"    // 重み付き無向連結グラフにおける最小全域木のコストを求める．O(|E|*log|V|).",
			"    T prim(int root = 0) {",
			"        assert(0 <= root and root < order());",
			"        T res = 0;",
			"        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, std::greater<std::pair<T, int> > > pque;",
			"        pque.emplace(0, root);",
			"        bool seen[order()] = {};",
			"        while(!pque.empty()) {",
			"            auto [cost, u] = pque.top();",
			"            pque.pop();",
			"            if(seen[u]) continue;",
			"            seen[u] = true;",
			"            res += cost;",
			"            for(const auto &[v, cost] : m_g[u]) {",
			"                if(!seen[v]) pque.emplace(cost, v);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Prim's Algorithm（最小全域木）"
	},
	"PrimalDual": {
		"scope": "cpp",
		"prefix": "PrimalDual",
		"body": [
			"template <typename Flow, typename Cost>  // Flow:容量の型, Cost:コストの型.",
			"class PrimalDual {",
			"    struct Edge {",
			"        int to;     // to:=(行き先ノード).",
			"        Flow cap;   // cap:=(容量).",
			"        Cost cost;  // cost:=(単位コスト).",
			"        int rev;    // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, Flow cap_, Cost cost_, int rev_) : to(to_), cap(cap_), cost(cost_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    static constexpr Cost infinity_cost() { return std::numeric_limits<Cost>::max(); }",
			"    void dijkstra(int s, const std::vector<Cost> &pot, std::vector<Cost> &d, std::vector<int> &prev_v, std::vector<int> &prev_e) {",
			"        std::fill(d.begin(), d.end(), infinity_cost());",
			"        d[s] = 0;",
			"        std::priority_queue<std::pair<Cost, int>, std::vector<std::pair<Cost, int> >, std::greater<std::pair<Cost, int> > > pque;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(d[v] < dist) continue;",
			"            for(int i = 0, n = m_g[v].size(); i < n; ++i) {",
			"                const Edge &e = m_g[v][i];",
			"                Cost new_cost = e.cost + pot[v] - pot[e.to];",
			"                if(e.cap > 0 and d[e.to] > d[v] + new_cost) {",
			"                    d[e.to] = d[v] + new_cost;",
			"                    prev_v[e.to] = v;",
			"                    prev_e[e.to] = i;",
			"                    pque.emplace(d[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    PrimalDual() : PrimalDual(0) {}",
			"    explicit PrimalDual(size_t vn) : m_g(vn) {}",
			"",
			"    static constexpr Flow infinity_flow() { return std::numeric_limits<Flow>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量cap[flows]，単位コストcost[cost/flow]の有向辺を追加する．",
			"    int add_edge(int from, int to, Flow cap, Cost cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        assert(cost >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, cost, idx_to);",
			"        m_g[to].emplace_back(from, 0, -cost, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ソースからシンクまでの最小費用[costs]（単位コスト[cost/flow]とフロー[flows]の積の総和）を求める．",
			"    // 返り値は流量[flows]と最小費用[costs]．O(F*|E|*log|V|).",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t) { return slope(s, t, infinity_flow()).back(); }",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t, Flow flow) { return slope(s, t, flow).back(); }",
			"    std::vector<std::pair<Flow, Cost> > slope(int s, int t) { return slope(s, t, infinity_flow()); }",
			"    std::vector<std::pair<Flow, Cost> > slope(int s, int t, Flow flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        Flow rest = flow;                                   // rest:=(残流量).",
			"        Cost sum = 0;                                       // sum:=(合計費用).",
			"        Cost prev_cost = -1;                                // prev_cost:=(直前のフローにおける単位コスト[cost/flow]).",
			"        std::vector<std::pair<Flow, Cost> > res({{0, 0}});  // res[]:=(流量とコストの関係の折れ線). 値は狭義単調増加．",
			"        std::vector<Cost> d(order());                       // d[v]:=(ノートsからvまでの最小単位コスト).",
			"        std::vector<Cost> pot(order(), 0);                  // pot[v]:=(ノードvのポテンシャル).",
			"        std::vector<int> prev_v(order());                   // prev_v[v]:=(ノードvの直前に訪れるノード). 逆方向経路．",
			"        std::vector<int> prev_e(order());                   // prev_e[v]:=(ノードvの直前に通る辺). 逆方向経路．",
			"        while(rest > 0) {",
			"            dijkstra(s, pot, d, prev_v, prev_e);",
			"            if(d[t] == infinity_cost()) break;  // これ以上流せない場合．",
			"            for(int v = 0, n = order(); v < n; ++v) pot[v] += d[v];",
			"            Flow tmp = rest;",
			"            for(int v = t; v != s; v = prev_v[v]) tmp = std::min(tmp, m_g[prev_v[v]][prev_e[v]].cap);",
			"            rest -= tmp;",
			"            sum += pot[t] * tmp;",
			"            if(pot[t] == prev_cost) res.pop_back();",
			"            res.emplace_back(flow - rest, sum);",
			"            for(int v = t; v != s; v = prev_v[v]) {",
			"                Edge &e = m_g[prev_v[v]][prev_e[v]];",
			"                e.cap -= tmp;",
			"                m_g[v][e.rev].cap += tmp;",
			"            }",
			"            prev_cost = pot[t];",
			"        }",
			"        return res;",
			"    }",
			"    // 辺の情報を返す．",
			"    std::tuple<int, int, Flow, Cost, Flow> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, e.cost, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, cost, flow).",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "最小費用流"
	},
	"RollbackUnionFind": {
		"scope": "cpp",
		"prefix": "RollbackUnionFind",
		"body": [
			"class RollbackUnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親番号). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"    // m_history[]:=(1つ手前の状態). tuple of (x, m_par[x], y, m_par[y]).",
			"    std::stack<std::tuple<int, int, int, int> > m_history;",
			"",
			"public:",
			"    RollbackUnionFind() : RollbackUnionFind(0) {}",
			"    explicit RollbackUnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // 現在のインデックスを返す．O(1).",
			"    int index() const { return m_history.size(); }",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根番号を返す．O(logN).",
			"    int root(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        return root(m_par[x]);",
			"    }",
			"    // 要素xが属するグループのサイズを返す．O(logN).",
			"    int size(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．O(logN).",
			"    bool is_same(int x, int y) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素xが属するグループと要素yが属するグループとを併合する．O(logN).",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;  // Do nothing.",
			"        m_history.emplace(x, m_par[x], y, m_par[y]);",
			"        if(size(x) < size(y)) std::swap(x, y);  // Merge technique (union by size).",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    // 1つ手前の状態に戻る．O(1).",
			"    int rollback() {",
			"        assert(!m_history.empty());",
			"        m_par[std::get<0>(m_history.top())] = std::get<1>(m_history.top());",
			"        m_par[std::get<2>(m_history.top())] = std::get<3>(m_history.top());",
			"        m_history.pop();",
			"        return index();",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"        std::stack<std::tuple<int, int, int, int> >().swap(m_history);",
			"    }",
			"};"
		],
		"description": "Rollback付きUnion-Find"
	},
	"SCC": {
		"scope": "cpp",
		"prefix": "SCC",
		"body": [
			"// 強連結成分分解．",
			"class SCC {",
			"    std::vector<std::vector<int> > m_g;  // m_g[v][]:=(ノードvの隣接リスト).",
			"",
			"public:",
			"    SCC() : SCC(0) {}",
			"    explicit SCC(int vn) : m_g(vn) {}",
			"",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 有向辺を張る．",
			"    void add_edge(int from, int to) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].push_back(to);",
			"    }",
			"    // return pair of (# of SCCs, SCC id of each nodes).",
			"    std::pair<int, std::vector<int> > scc() const {",
			"        int num_sccs = 0;               // num_sccs:=(SCCsの数).",
			"        std::vector<int> ids(order());  // ids[v]:=(ノードvが属するSCCのID).",
			"        // ord[v]:=(DFS木におけるノードvの行きがけ順序).",
			"        // low[v]:=(DFS木において，ノードvから葉方向に0回以上，後退辺を高々1回用いて到達できるノードwのord[w]の最小値).",
			"        std::vector<int> ord(order(), -1), low(order());",
			"        int now = 0;",
			"        std::stack<int> visited;",
			"        auto dfs = [&](auto self, int u) -> void {",
			"            ord[u] = low[u] = now++;",
			"            visited.push(u);",
			"            for(int to : m_g[u]) {",
			"                if(ord[to] == -1) {",
			"                    self(self, to);",
			"                    low[u] = std::min(low[u], low[to]);",
			"                } else {",
			"                    low[u] = std::min(low[u], ord[to]);",
			"                }",
			"            }",
			"            if(low[u] == ord[u]) {",
			"                while(true) {",
			"                    int v = visited.top();",
			"                    visited.pop();",
			"                    ord[v] = order();  // inf.",
			"                    ids[v] = num_sccs;",
			"                    if(v == u) break;",
			"                }",
			"                num_sccs++;",
			"            }",
			"        };",
			"        for(int v = 0; v < order(); ++v) {",
			"            if(ord[v] == -1) dfs(dfs, v);",
			"        }",
			"        return {num_sccs, ids};",
			"    }",
			"    // 有向グラフを強連結成分分解する．O(|V|+|E|).",
			"    std::vector<std::vector<int> > decompose() const {",
			"        const auto &&[num_sccs, ids] = scc();",
			"        std::vector<std::vector<int> > sccs(num_sccs);",
			"        for(int v = 0; v < order(); ++v) sccs[ids[v]].push_back(v);",
			"        return sccs;",
			"    }",
			"};"
		],
		"description": "強連結成分分解"
	},
	"SegmentSet": {
		"scope": "cpp",
		"prefix": "SegmentSet",
		"body": [
			"// 整数の集合を区間で管理するデータ構造．",
			"template <typename T>",
			"class SegmentSet {",
			"    std::set<std::pair<T, T> > m_st;  // m_st:=(整数の集合). 連続している区間[l,r)をpair(l,r)で表現する．",
			"",
			"public:",
			"    SegmentSet() {",
			"        // 番兵を配置．",
			"        m_st.emplace(-infinity() - 2, -infinity() - 1);",
			"        m_st.emplace(infinity() + 2, infinity() + 3);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max() - 3; }",
			"    // 整数xを追加する．O(logN).",
			"    bool insert(T x) { return insert(x, x + 1); }",
			"    // 区間[l,r)の整数を追加する．O(logN).",
			"    bool insert(T l, T r) {",
			"        assert(-infinity() <= l and l < r and r <= infinity() + 1);",
			"        auto iter1 = std::prev(m_st.lower_bound(std::pair<T, T>(l + 1, l + 1)));",
			"        auto [l1, r1] = *iter1;",
			"        if(r <= r1) return false;  // 全て集合に含まれている場合．",
			"        if(l <= r1) l = l1;",
			"        else iter1++;",
			"        auto iter3 = m_st.lower_bound(std::pair<T, T>(r, r));",
			"        auto iter2 = std::prev(iter3);",
			"        auto [l2, r2] = *iter2;",
			"        auto [l3, r3] = *iter3;",
			"        if(r == l3) {",
			"            m_st.erase(iter1, ++iter3);",
			"            m_st.emplace(l, r3);",
			"        } else {",
			"            m_st.erase(iter1, iter3);",
			"            if(r <= r2) m_st.emplace(l, r2);",
			"            else m_st.emplace(l, r);",
			"        }",
			"        return true;",
			"    }",
			"    // 整数xを削除する．O(logN).",
			"    bool erase(T x) { return erase(x, x + 1); }",
			"    // 区間[l,r)の整数を削除する．O(logN).",
			"    bool erase(T l, T r) {",
			"        assert(-infinity() <= l and l < r and r <= infinity() + 1);",
			"        auto iter1 = std::prev(m_st.lower_bound(std::pair<T, T>(l + 1, l + 1)));",
			"        auto iter3 = m_st.lower_bound(std::pair<T, T>(r, r));",
			"        auto iter2 = std::prev(iter3);",
			"        auto [l1, r1] = *iter1;",
			"        auto [l2, r2] = *iter2;",
			"        if(l < r1) {",
			"            m_st.erase(iter1, iter3);",
			"            if(l1 < l) m_st.emplace(l1, l);",
			"        } else {",
			"            if(iter1 == iter2) return false;  // 全て集合に含まれていない場合．",
			"            m_st.erase(++iter1, iter3);",
			"        }",
			"        if(r < r2) m_st.emplace(r, r2);",
			"        return true;",
			"    }",
			"    // 整数xが集合に含まれているか判定する．O(logN).",
			"    int contains(T x) const { return contains(x, x + 1); }",
			"    // 区間[l,r)の整数が集合に含まれているか判定する．O(logN).",
			"    int contains(T l, T r) const {",
			"        assert(-infinity() <= l and l < r and r <= infinity() + 1);",
			"        const auto &[_, pr] = *std::prev(m_st.lower_bound(std::pair<T, T>(l + 1, l + 1)));",
			"        if(pr <= l) return 0;  // 全て含まれていない場合．",
			"        if(pr < r) return 1;   // 一部含まれている場合．",
			"        return 2;              // 全て含まれている場合．",
			"    }",
			"    // x以上の整数で集合に含まれない最小の値 (mex: Minimum EXcluded value) を求める．O(logN).",
			"    T mex(T x) const {",
			"        assert(-infinity() <= x and x <= infinity());",
			"        const auto &[_, r] = *std::prev(m_st.lower_bound(std::pair<T, T>(x + 1, x + 1)));",
			"        return (x < r ? r : x);",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const SegmentSet &ob) {",
			"        os << \"[\";",
			"        const int n = ob.m_st.size();",
			"        int cnt = 0;",
			"        for(auto iter = ob.m_st.cbegin(); iter != ob.m_st.cend(); ++iter) {",
			"            if(cnt != 0 and cnt != n - 1) {",
			"                const auto &[l, r] = *iter;",
			"                os << (cnt == 1 ? \"\" : \" \") << \"[\" << l << \", \" << r << \")\";",
			"            }",
			"            cnt++;",
			"        }",
			"        os << \"]\";",
			"        return os;",
			"    }",
			"};"
		],
		"description": "整数の集合を区間で管理するデータ構造"
	},
	"SegmentSieve": {
		"scope": "cpp",
		"prefix": "SegmentSieve",
		"body": [
			"// 区間篩．",
			"class SegmentSieve {",
			"    long long m_l, m_r;",
			"    long long m_sr;                                  // m_sr:=√r.",
			"    std::vector<long long> m_small;                  // m_small[n]:=(区間[2,√r)の自然数nにおける最小の素因数).",
			"    std::vector<std::map<long long, int> > m_large;  // m_large[n-m_l][]:=(区間[m_l,m_r)の自然数nにおける区間[2,√r)のいくつかの素因数).",
			"    std::vector<long long> m_aux;                    // m_aux[n-m_l]:=(m_large[n-m_l][]の積).",
			"",
			"public:",
			"    // constructor. 区間[l,r)の自然数を篩にかける．制約の目安はおおよそ 2<=l<r<=1e12, r-l<=1e6．",
			"    SegmentSieve() : SegmentSieve(2, 3) {}",
			"    explicit SegmentSieve(long long l, long long r) : m_l(l), m_r(r), m_large(r - l), m_aux(r - l, 1) {",
			"        assert(2 <= l and l < r);",
			"        m_sr = std::sqrt(m_r) + 1;",
			"        m_small.assign(m_sr, -1);",
			"        std::iota(m_small.begin() + 2, m_small.end(), 2);",
			"        for(long long p = 2; p * p < m_r; ++p) {",
			"            if(m_small[p] == p) {",
			"                for(long long q = p * p; q < m_sr; q += p) m_small[q] = p;",
			"                for(long long q = std::max<long long>((m_l + p - 1) / p, 2) * p; q < m_r; q += p) {",
			"                    long long tmp = q;",
			"                    while(tmp % p == 0 and m_aux[q - m_l] * m_aux[q - m_l] < m_r) {",
			"                        m_large[q - m_l][p]++;",
			"                        m_aux[q - m_l] *= p;",
			"                        tmp /= p;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        return m_large[n - m_l].size() == 0;",
			"    }",
			"    // 高速素因数分解．",
			"    std::map<long long, int> prime_factorize(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        std::map<long long, int> res = m_large[n - m_l];",
			"        n /= m_aux[n - m_l];",
			"        if(n >= m_sr) {",
			"            res[n]++;",
			"            return res;",
			"        }",
			"        while(n > 1) {",
			"            res[m_small[n]]++;",
			"            n /= m_small[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<long long> divisors(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        std::vector<long long> res({1});",
			"        const std::map<long long, int> &&pf = prime_factorize(n);",
			"        int capacity = 1;",
			"        for(const auto &[_, cnt] : pf) capacity *= (cnt + 1);",
			"        res.reserve(capacity);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            long long b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"};"
		],
		"description": "区間篩"
	},
	"SegmentTree": {
		"scope": "cpp",
		"prefix": "SegmentTree",
		"body": [
			"template <typename S>",
			"class SegmentTree {",
			"    using Op = std::function<S(const S &, const S &)>;",
			"",
			"    Op m_op;                // S m_op(S,S):=(二項演算関数).",
			"    S m_e;                  // m_e:=(単位元).",
			"    int m_sz;               // m_sz:=(要素数).",
			"    int m_n;                // m_n:=(葉の数).",
			"    std::vector<S> m_tree;  // m_tree[]:=(完全二分木). 1-based index.",
			"",
			"public:",
			"    // constructor. O(N).",
			"    SegmentTree(){};",
			"    explicit SegmentTree(const Op &op, const S &e, size_t n) : m_op(op), m_e(e), m_sz(n), m_n(1) {",
			"        while(m_n < size()) m_n <<= 1;",
			"        m_tree.assign(2 * m_n, identity());",
			"    }",
			"    explicit SegmentTree(const Op &op, const S &e, const std::vector<S> &v) : SegmentTree(op, e, v.size()) {",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + m_n);",
			"        for(int i = m_n - 1; i >= 1; --i) m_tree[i] = m_op(m_tree[i << 1], m_tree[i << 1 | 1]);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // 単位元を返す．",
			"    S identity() const { return m_e; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const S &a) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        m_tree[k] = a;",
			"        while(k >>= 1) m_tree[k] = m_op(m_tree[k << 1], m_tree[k << 1 | 1]);",
			"    }",
			"    // k番目の要素を返す．O(1).",
			"    S prod(int k) const {",
			"        assert(0 <= k and k < size());",
			"        return m_tree[k + m_n];",
			"    }",
			"    // 区間[l,r)の要素の総積 v[l]•v[l+1]•...•v[r-1] を求める．O(logN).",
			"    S prod(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        S val_l = identity(), val_r = identity();",
			"        l += m_n, r += m_n;",
			"        while(l < r) {",
			"            if(l & 1) val_l = m_op(val_l, m_tree[l++]);",
			"            if(r & 1) val_r = m_op(m_tree[--r], val_r);",
			"            l >>= 1, r >>= 1;",
			"        }",
			"        return m_op(val_l, val_r);",
			"    }",
			"    // 区間全体の要素の総積を返す．O(1).",
			"    S prod_all() const { return m_tree[1]; }",
			"    // jud(prod(l,-))==true となる区間の最右位値を二分探索する．",
			"    // ただし要素列には単調性があり，また jud(e)==true であること．O(logN).",
			"    int most_right(const std::function<bool(const S &)> &jud, int l) const {",
			"        assert(jud(identity()) == true);",
			"        assert(0 <= l and l <= size());",
			"        if(l == size()) return size();",
			"        S val = identity();",
			"        l += m_n;",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            S &&tmp = m_op(val, m_tree[l]);",
			"            if(!jud(tmp)) {",
			"                while(l < m_n) {",
			"                    l <<= 1;",
			"                    S &&tmp2 = m_op(val, m_tree[l]);",
			"                    if(jud(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - m_n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return size();",
			"    }",
			"    // jud(prod(-,r))==true となる区間の最左位値を二分探索する．",
			"    // ただし要素列には単調性があり，また jud(e)==true であること．O(logN).",
			"    int most_left(const std::function<bool(const S &)> &jud, int r) const {",
			"        assert(jud(identity()) == true);",
			"        assert(0 <= r and r <= size());",
			"        if(r == 0) return 0;",
			"        S val = identity();",
			"        r += m_n;",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            S &&tmp = m_op(m_tree[r], val);",
			"            if(!jud(tmp)) {",
			"                while(r < m_n) {",
			"                    r = (r << 1) | 1;",
			"                    S &&tmp2 = m_op(m_tree[r], val);",
			"                    if(jud(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - m_n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() { std::fill(m_tree.begin(), m_tree.end(), identity()); }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const SegmentTree &segtree) {",
			"        int l = 1, r = 2;",
			"        while(l < 2 * segtree.m_n) {",
			"            os << (l == 1 ? \"[\" : \" \");",
			"            for(int i = l; i < r; ++i) os << (i == l ? \"[\" : \" \") << segtree.m_tree[i];",
			"            os << \"]\" << (r == 2 * segtree.m_n ? \"]\" : \"\\n\");",
			"            l <<= 1, r <<= 1;",
			"        }",
			"        return os;",
			"    }",
			"};"
		],
		"description": "Segment Tree"
	},
	"Sieve": {
		"scope": "cpp",
		"prefix": "Sieve",
		"body": [
			"// Sieve of Eratosthenes（エラトステネスの篩）.",
			"class Sieve {",
			"    int m_mx;                // m_mx:=(篩にかける最大の自然数).",
			"    std::vector<int> m_lpf;  // m_lpf[n]:=(自然数nの最小の素因数). Least prime factor. m_lpf[n]==n のとき，nは素数．",
			"",
			"public:",
			"    // constructor. n以下の自然数を篩にかける．O(N*loglogN).",
			"    Sieve() : Sieve(51e4) {}",
			"    explicit Sieve(int n) : m_mx(n), m_lpf(n + 1, -1) {",
			"        assert(n >= 0);",
			"        std::iota(m_lpf.begin() + 2, m_lpf.end(), 2);",
			"        for(int p = 2; p * p <= m_mx; ++p) {",
			"            if(m_lpf[p] == p) {",
			"                for(int q = p * p; q <= m_mx; q += p) {",
			"                    if(m_lpf[q] == q) m_lpf[q] = p;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小の素因数を返す．O(1).",
			"    int lpf(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const std::map<int, int> &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    // オイラーのファイ関数．n以下でnと互いに素な自然数の個数を求める．",
			"    int totient(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        const std::map<int, int> &&pf = prime_factorize(n);",
			"        int res = n;",
			"        for(const auto &[p, cnt] : pf) res -= res / p;",
			"        return res;",
			"    }",
			"    // メビウス関数．O(N*loglogN).",
			"    std::vector<int> mobius() const {",
			"        std::vector<int> res(m_mx + 1, 1);  // res[n]:=μ(n).",
			"        for(int p = 2; p <= m_mx; ++p) {",
			"            if(m_lpf[p] == p) {",
			"                res[p] = -1;",
			"                for(int q = 2 * p; q <= m_mx; q += p) {",
			"                    if((q / p) % p == 0) res[q] = 0;  // nがある素数pで2回以上割り切れるとき，μ(n)=0.",
			"                    else res[q] = -res[q];            // nがk個の相異なる素因数で分解できるとき，μ(n)=(-1)^k.",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Sieve of Eratosthenes（エラトステネスの篩）"
	},
	"SparseTable": {
		"scope": "cpp",
		"prefix": "SparseTable",
		"body": [
			"// 結合則 (A•B)•C=A•(B•C) と冪等性 A•A=A が成り立つ演算（or, min, max, gcd, lcmなど）による区間クエリを求める．",
			"template <typename S>  // S:冪等半群の型.",
			"class SparseTable {",
			"    using Func = std::function<S(const S &, const S &)>;",
			"",
			"    Func m_op;                             // S m_op(S,S):=(二項演算関数).",
			"    int m_sz;                              // m_sz:=(要素数).",
			"    std::vector<int> m_l;                  // m_l[x]:=(2^k<=x となる最大の整数k).",
			"    std::vector<std::vector<S> > m_table;  // m_table[k][i]:=(区間[i,i+2^k)の総積).",
			"",
			"public:",
			"    // constructor. O(N*logN).",
			"    SparseTable() {}",
			"    explicit SparseTable(const Func &op, const std::vector<S> &v) : m_op(op), m_sz(v.size()), m_l(v.size() + 1, 0) {",
			"        for(int i = 2; i <= size(); ++i) m_l[i] = m_l[i >> 1] + 1;",
			"        m_table.resize(m_l[size()] + 1);",
			"        m_table[0].assign(v.begin(), v.end());",
			"        for(int k = 1; k <= m_l[size()]; ++k) {",
			"            m_table[k].resize(size() - (1 << k) + 1);",
			"            for(int i = 0; i <= size() - (1 << k); ++i) m_table[k][i] = m_op(m_table[k - 1][i], m_table[k - 1][i + (1 << (k - 1))]);",
			"        }",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // 区間[l,r)の総積を求める．O(1).",
			"    S fold(int l, int r) const {",
			"        assert(0 <= l and l < r and r <= size());",
			"        int k = m_l[r - l];",
			"        return m_op(m_table[k][l], m_table[k][r - (1 << k)]);",
			"    }",
			"};"
		],
		"description": ""
	},
	"TopologicalSort": {
		"scope": "cpp",
		"prefix": "TopologicalSort",
		"body": [
			"class TopologicalSort {",
			"    std::vector<std::vector<int> > m_g;  // m_g[v]:=(ノードvの隣接リスト).",
			"",
			"public:",
			"    TopologicalSort() : TopologicalSort(0) {}",
			"    explicit TopologicalSort(size_t vn) : m_g(vn) {}",
			"",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 有向辺を張る．",
			"    void add_edge(int from, int to) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].push_back(to);",
			"    }",
			"    // 任意のトポロジカルソートの解を求める．O(|E|).",
			"    std::vector<int> topological_sort() const {",
			"        std::vector<int> res;",
			"        res.reserve(order());",
			"        std::vector<int> deg(order(), 0);  // deg[v]:=(ノードvの入次数).",
			"        for(const std::vector<int> &edges : m_g) {",
			"            for(int to : edges) deg[to]++;",
			"        }",
			"        std::queue<int> que;",
			"        for(int i = 0, n = order(); i < n; ++i) {",
			"            if(deg[i] == 0) que.push(i);",
			"        }",
			"        while(!que.empty()) {",
			"            int u = que.front();",
			"            que.pop();",
			"            res.push_back(u);",
			"            for(int v : m_g[u]) {",
			"                if(--deg[v] == 0) que.push(v);",
			"            }",
			"        }",
			"        if(res.size() != order()) return std::vector<int>();  // 閉路がある場合．",
			"        return res;",
			"    }",
			"    // 考え得るトポロジカルソートの解を数え上げる．",
			"    // ノード数の実用上限目安は20程度．O(N*(2^N)).",
			"    template <typename Type = long long>",
			"    Type count_up() const {",
			"        assert(order() <= 30);",
			"        const int n = order();",
			"        std::vector<int> b(n, 0);  // b[v]:=(ノードvの隣接リストにある行き先ノードの集合).",
			"        for(int v = 0; v < n; ++v) {",
			"            for(int to : m_g[v]) b[v] |= 1 << to;",
			"        }",
			"        std::vector<Type> dp(1 << n, 0);  // dp[S]:=(ノード集合Sにおける解の通り数).",
			"        dp[0] = 1;",
			"        for(int bit = 0; bit < 1 << n; ++bit) {",
			"            for(int i = 0; i < n; ++i) {",
			"                if(!(bit >> i & 1) and !(bit & b[i])) dp[bit | 1 << i] += dp[bit];",
			"            }",
			"        }",
			"        return dp[(1 << n) - 1];",
			"    }",
			"};"
		],
		"description": "トポロジカルソート"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "UnionFind",
		"body": [
			"class UnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親番号). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"",
			"public:",
			"    UnionFind() : UnionFind(0) {}",
			"    explicit UnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根番号を返す．O(α(N)).",
			"    int root(int x) {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        return m_par[x] = root(m_par[x]);  // 経路圧縮．",
			"    }",
			"    // 要素xが属するグループのサイズを返す．",
			"    int size(int x) {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．",
			"    bool is_same(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素xが属するグループと要素yが属するグループとを併合する．",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;                // Do nothing.",
			"        if(size(x) < size(y)) std::swap(x, y);  // Merge technique (union by size).",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"    }",
			"};"
		],
		"description": "Union-Find（素集合データ構造）"
	},
	"popcount": {
		"scope": "cpp",
		"prefix": "popcount",
		"body": [
			"int popcount32(uint32_t n) {",
			"    constexpr uint32_t masks[5] = {0x55555555U, 0x33333333U, 0x0f0f0f0fU, 0x00ff00ffU, 0x0000ffffU};",
			"    for(int i = 0; i < 5; ++i) n = (n & masks[i]) + ((n >> (1 << i)) & masks[i]);",
			"    return n;",
			"}",
			"",
			"int popcount64(uint64_t n) {",
			"    constexpr uint64_t masks[6] = {0x5555555555555555ULL, 0x3333333333333333ULL, 0x0f0f0f0f0f0f0f0fULL,",
			"                                   0x00ff00ff00ff00ffULL, 0x0000ffff0000ffffULL, 0x00000000ffffffffULL};",
			"    for(int i = 0; i < 6; ++i) n = (n & masks[i]) + ((n >> (1 << i)) & masks[i]);",
			"    return n;",
			"}"
		],
		"description": ""
	},
	"calc_tree_diameter": {
		"scope": "cpp",
		"prefix": "calc_tree_diameter",
		"body": [
			"// 木の直径を求める．O(|V|).",
			"std::tuple<int, int, int> calc_tree_diameter(const std::vector<std::vector<int> > &g) {",
			"    if(g.size() == 0) return {-1, -1, -1};",
			"    int endpoint;",
			"    std::vector<int> d(g.size());",
			"    std::queue<int> que;",
			"    auto bfs = [&](int s) -> void {",
			"        endpoint = s;",
			"        std::fill(d.begin(), d.end(), -1);",
			"        d[s] = 0;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int u = que.front();",
			"            que.pop();",
			"            endpoint = u;",
			"            for(int v : g[u]) {",
			"                if(d[v] != -1) continue;",
			"                d[v] = d[u] + 1;",
			"                que.push(v);",
			"            }",
			"        }",
			"    };",
			"    bfs(0);",
			"    int tmp = endpoint;",
			"    bfs(endpoint);",
			"    return {d[endpoint], tmp, endpoint};  // tuple of (diameter, endpoint1, endpoint2).",
			"}",
			"",
			"// 重み付き木の直径を求める．O(|V|).",
			"template <typename Type>",
			"std::tuple<Type, int, int> calc_tree_diameter(const std::vector<std::vector<std::pair<int, Type> > > &g) {",
			"    if(g.size() == 0) return {-1, -1, -1};",
			"    int endpoint;",
			"    Type diameter;",
			"    std::vector<Type> d(g.size());",
			"    std::vector<bool> seen(g.size());",
			"    std::queue<int> que;",
			"    auto bfs = [&](int s) -> void {",
			"        endpoint = s;",
			"        diameter = d[s] = 0;",
			"        std::fill(seen.begin(), seen.end(), false);",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int u = que.front();",
			"            que.pop();",
			"            seen[u] = true;",
			"            if(d[u] > diameter) endpoint = u, diameter = d[u];",
			"            for(const auto &[v, cost] : g[u]) {",
			"                if(seen[v]) continue;",
			"                d[v] = d[u] + cost;",
			"                que.emplace(v);",
			"            }",
			"        }",
			"    };",
			"    bfs(0);",
			"    int tmp = endpoint;",
			"    bfs(endpoint);",
			"    return {diameter, tmp, endpoint};  // tuple of (diameter, endpoint1, endpoint2).",
			"}"
		],
		"description": "木の直径"
	},
	"calc_viewing_range": {
		"scope": "cpp",
		"prefix": "calc_viewing_range",
		"body": [
			"// 見晴らし範囲．",
			"// H[] within [left[i], right[i]) <= H[i] (left[i] <= i < right[i]) となるleft[], right[]を求める．O(N).",
			"template <typename Type, typename Func = std::function<bool(Type, Type)> >",
			"std::pair<std::vector<int>, std::vector<int> > calc_viewing_range(",
			"    const std::vector<Type> &h,",
			"    const Func &comp = [](const Type &a, const Type &b) -> bool { return a <= b; }) {",
			"    const int n = h.size();",
			"    std::vector<int> left(n, 0), right(n, n);",
			"    // left side.",
			"    std::stack<std::pair<Type, int> > stack_left;",
			"    for(int i = 0; i < n; ++i) {",
			"        while(!stack_left.empty() and comp(stack_left.top().first, h[i])) stack_left.pop();",
			"        if(!stack_left.empty()) left[i] = stack_left.top().second + 1;",
			"        stack_left.push({h[i], i});",
			"    }",
			"    // right side.",
			"    std::stack<std::pair<Type, int> > stack_right;",
			"    for(int i = n - 1; i >= 0; --i) {",
			"        while(!stack_right.empty() and comp(stack_right.top().first, h[i])) stack_right.pop();",
			"        if(!stack_right.empty()) right[i] = stack_right.top().second;",
			"        stack_right.push({h[i], i});",
			"    }",
			"    return {left, right};",
			"}"
		],
		"description": "見晴らし範囲"
	},
	"compress": {
		"scope": "cpp",
		"prefix": "compress",
		"body": [
			"// 座標圧縮．",
			"template <typename Type>",
			"std::vector<Type> compress(std::vector<Type> &v) {",
			"    const int n = v.size();",
			"    std::vector<Type> key = v;",
			"    std::sort(key.begin(), key.end());",
			"    key.erase(std::unique(key.begin(), key.end()), key.end());",
			"    for(int i = 0; i < n; ++i) v[i] = std::lower_bound(key.begin(), key.end(), v[i]) - key.begin();",
			"    return key;",
			"}"
		],
		"description": "座標圧縮"
	},
	"crt": {
		"scope": "cpp",
		"prefix": "crt",
		"body": [
			"// Chinese Remainder Theorem（中国剰余定理）.",
			"// 非負整数m1,b1,m2,b2に対して x≡b1 (mod m1) かつ x≡b2 (mod m2) を満たす非負整数x (0≦x＜lcm(m1,m2)) を求める．",
			"// 解xが存在する必要十分条件は b1≡b2 (mod gcd(m1,m2)) であること．",
			"// 返り値はpair of (x, lcm(m1,m2))．解なしの場合，(0,-1)を返す．",
			"std::pair<long long, long long> crt(long long b1, long long m1, long long b2, long long m2) {",
			"    long long p, q;",
			"    long long d = extgcd(m1, m2, p, q);     // p is inverse of m1/d (mod m2/d).",
			"    if((b2 - b1) % d != 0) return {0, -1};  // 解なし．",
			"    long long m = m1 / d * m2;              // lcm(m1,m2).",
			"    long long tmp = (b2 - b1) / d * p % (m2 / d);",
			"    long long r = (b1 + m1 * tmp) % m;",
			"    if(r < 0) r += m;",
			"    return {r, m};",
			"}",
			"",
			"// Chinese Remainder Theorem（中国剰余定理）.",
			"// 各iについて，非負整数m[i],b[i]に対して x≡b[i] (mod m[i]) を満たす非負整数x (0≦x＜lcm(m[0],m[1],...,m[N-1])) を求める．",
			"// 返り値はpair of (x, lcm(m[0],m[1],...,m[N-1]))．解なしの場合，(0,-1)を返す．",
			"template <typename Type>",
			"std::pair<long long, long long> crt(const std::vector<Type> &bs, const std::vector<Type> &ms) {",
			"    assert(bs.size() == ms.size());",
			"    long long r = 0, m = 1;",
			"    for(int i = 0, n = bs.size(); i < n; ++i) {",
			"        const auto &&[nr, nm] = crt(r, m, bs[i], ms[i]);",
			"        if(nr == 0 and nm == -1) return {0, -1};  // 解なし．",
			"        r = nr, m = nm;",
			"    }",
			"    return {r, m};",
			"}"
		],
		"description": "Chinese Remainder Theorem（中国剰余定理）"
	},
	"divisors": {
		"scope": "cpp",
		"prefix": "divisors",
		"body": [
			"// 約数列挙．O(√N).",
			"template <typename Type>",
			"std::vector<Type> divisors(Type n) {",
			"    assert(n >= 1);",
			"    std::vector<Type> res;  // res[]:=(自然数nの約数の集合).",
			"    for(Type p = 1; p * p <= n; ++p) {",
			"        if(n % p == 0) {",
			"            res.push_back(p);",
			"            Type q = n / p;",
			"            if(q != p) res.push_back(q);",
			"        }",
			"    }",
			"    std::sort(res.begin(), res.end());",
			"    return res;",
			"}"
		],
		"description": "約数列挙"
	},
	"edit_distance": {
		"scope": "cpp",
		"prefix": "edit_distance",
		"body": [
			"// Edit Distance（編集距離）.",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|*|T|).",
			"template <class Sequence>",
			"std::vector<std::vector<int> > edit_distance(const Sequence &s, const Sequence &t) {",
			"    const int n = s.size(), m = t.size();",
			"    // dp[i][j]:=(s[:i]とt[:j]の編集距離).",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));",
			"    for(int i = 1; i <= n; ++i) dp[i][0] = i;",
			"    for(int j = 1; j <= m; ++j) dp[0][j] = j;",
			"    for(int i = 1; i <= n; ++i) {",
			"        for(int j = 1; j <= m; ++j) {",
			"            dp[i][j] = std::min({dp[i - 1][j] + 1,",
			"                                 dp[i][j - 1] + 1,",
			"                                 dp[i - 1][j - 1] + (s[i - 1] == t[j - 1] ? 0 : 1)});",
			"        }",
			"    }",
			"    return dp;",
			"}"
		],
		"description": "Edit Distance（編集距離）"
	},
	"extgcd": {
		"scope": "cpp",
		"prefix": "extgcd",
		"body": [
			"// 拡張ユークリッドの互除法．",
			"// ax+by=gcd(a,b) を満たす整数の組(x,y)を求め，gcd(a,b)を返す．O(log(min(a,b))).",
			"template <typename Type>",
			"Type extgcd(Type a, Type b, Type &x, Type &y) {",
			"    if(b == 0) {",
			"        x = 1, y = 0;",
			"        return a;",
			"    }",
			"    Type d = extgcd(b, a % b, y, x);",
			"    y -= a / b * x;",
			"    return d;",
			"}"
		],
		"description": "拡張ユークリッドの互除法"
	},
	"floor_sum": {
		"scope": "cpp",
		"prefix": "floor_sum",
		"body": [
			"// sum_{x=0}^{n-1} floor((a*x+b)/m) を求める．O(log m).",
			"long long floor_sum(long long n, long long m, long long a, long long b) {",
			"    assert(0 <= n and n < 1LL << 32);",
			"    assert(1 <= m and m < 1LL << 32);",
			"    long long res = 0;",
			"    if(a >= m) {",
			"        res += a / m * (n * (n - 1) / 2);",
			"        a %= m;",
			"    } else if(a < 0) {",
			"        long long na = (a % m + m) % m;",
			"        res -= (na - a) / m * (n * (n - 1) / 2);",
			"        a = na;",
			"    }",
			"    if(b >= m) {",
			"        res += b / m * n;",
			"        b %= m;",
			"    } else if(b < 0) {",
			"        long long nb = (b % m + m) % m;",
			"        res -= (nb - b) / m * n;",
			"        b = nb;",
			"    }",
			"    long long y_max = a * n + b;",
			"    if(y_max >= m) res += floor_sum(y_max / m, a, m, y_max % m);",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"garner": {
		"scope": "cpp",
		"prefix": "garner",
		"body": [
			"// 各iについて x≡b[i] (mod m[i]) を満たす最小の非負整数x (0≦x＜m[0]m[1]...m[N-1]) を求める．",
			"// ただし，以下の制約を満たすこと．",
			"//   - 任意のiについて，0≦b[i]<m[i].",
			"//   - 任意のi,j (i≠j) について，gcd(m[i],m[j])=1.",
			"long long garner(const std::vector<int> &bs, const std::vector<int> &ms) {",
			"    assert(bs.size() == ms.size());",
			"    long long x = 0;",
			"    long long m_prod = 1;",
			"    for(int i = 0, n = bs.size(); i < n; ++i) {",
			"        long long t = (bs[i] - x) * mod_inv(m_prod, ms[i]) % ms[i];",
			"        if(t < 0) t += ms[i];",
			"        x += m_prod * t;",
			"        m_prod *= ms[i];",
			"    }",
			"    return x;",
			"}",
			"",
			"// 各iについて x≡b[i] (mod m[i]) を満たす最小の非負整数x (0≦x＜m[0]m[1]...m[N-1]) を求め，ある整数Mに対して x mod M を返す．",
			"// ただし，以下の制約を満たすこと．",
			"//   - 任意のiについて，0≦b[i]<m[i].",
			"//   - 任意のi,j (i≠j) について，gcd(m[i],m[j])=1.",
			"int garner(const std::vector<int> &bs, const std::vector<int> &ms, int mod) {",
			"    assert(bs.size() == ms.size());",
			"    const int n = bs.size();",
			"    std::vector<long long> coeffs(n, 1);     // coeffs[k]:=m[0]m[1]...m[k-1].",
			"    std::vector<long long> constants(n, 0);  // constants[k]:=t[0]+t[1]m[0]+...+t[k-1]m[0]m[1]...m[k-2].",
			"    long long x = 0;",
			"    long long m_prod = 1;",
			"    for(int i = 0; i < n; ++i) {",
			"        long long t = (bs[i] - constants[i]) * mod_inv(coeffs[i], ms[i]) % ms[i];",
			"        if(t < 0) t += ms[i];",
			"        for(int j = i + 1; j < n; ++j) {",
			"            constants[j] = (constants[j] + coeffs[j] * t) % ms[j];",
			"            coeffs[j] = coeffs[j] * ms[i] % ms[j];",
			"        }",
			"        x = (x + m_prod * t) % mod;",
			"        m_prod = m_prod * ms[i] % mod;",
			"    }",
			"    return x;",
			"}"
		],
		"description": "Garner's Algorithm（中国剰余定理）"
	},
	"igcd, ilcm": {
		"scope": "cpp",
		"prefix": "igcd, ilcm",
		"body": [
			"template<typename Type> Type igcd(Type a,Type b){return (b==0)?a:igcd(b,a%b);}",
			"template<typename Type> Type ilcm(Type a,Type b){return a/igcd(a,b)*b;}"
		],
		"description": "最大公約数，最小公倍数"
	},
	"ipow": {
		"scope": "cpp",
		"prefix": "ipow",
		"body": [
			"// 繰返し二乗法．O(logK).",
			"long long ipow(long long n, long long k) {",
			"    assert(k >= 0);",
			"    if(k == 0) return 1;",
			"    long long &&res = ipow(n * n, k >> 1);",
			"    if(k & 1LL) res *= n;",
			"    return res;",
			"}"
		],
		"description": "繰返し二乗法"
	},
	"isqrt": {
		"scope": "cpp",
		"prefix": "isqrt",
		"body": [
			"// 平方根（ニュートン法）．",
			"double isqrt(double x, const double eps = 1e-10) {",
			"    assert(x >= 0.0);",
			"    double res = 5.0;",
			"    while(1) {",
			"        double tmp = (x / res + res) / 2;",
			"        if(std::abs(tmp - res) < eps) break;",
			"        res = tmp;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "平方根（ニュートン法）"
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"// 素数判定．O(√N).",
			"template <typename Type>",
			"bool is_prime(Type n) {",
			"    assert(n >= 0);",
			"    if(n < 2) return false;",
			"    if(n == 2) return true;",
			"    if(n % 2 == 0) return false;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        if(n % p == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"lcs": {
		"scope": "cpp",
		"prefix": "lcs",
		"body": [
			"// Longest Common Subsequence（最長共通部分列）.",
			"// 引数はSTLのシーケンスコンテナ．O(|A|*|B|).",
			"template <class Sequence>",
			"Sequence lcs(const Sequence &a, const Sequence &b) {",
			"    const int n = a.size(), m = b.size();",
			"    // dp[i][j]:=(a[:i]とb[:j]のLCSの長さ).",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));",
			"    for(int i = 1; i <= n; ++i) {",
			"        for(int j = 1; j <= m; ++j) {",
			"            dp[i][j] = (a[i - 1] == b[j - 1] ? dp[i - 1][j - 1] + 1 : std::max(dp[i - 1][j], dp[i][j - 1]));",
			"        }",
			"    }",
			"    Sequence sub(dp[n][m], 0);  // sub[]:=(配列a, bのLCS).",
			"    int i = n, j = m, k = dp[n][m];",
			"    while(k > 0) {",
			"        if(a[i - 1] == b[j - 1]) {",
			"            sub[k - 1] = a[i - 1];",
			"            i--, j--, k--;",
			"        } else if(dp[i][j] == dp[i - 1][j]) {",
			"            i--;",
			"        } else {",
			"            j--;",
			"        }",
			"    }",
			"    return sub;",
			"}"
		],
		"description": "Longest Common Subsequence（最長共通部分列）"
	},
	"linear_congruence": {
		"scope": "cpp",
		"prefix": "linear_congruence",
		"body": [
			"// 一次合同式 ax≡c (mod m) の解をすべて求める．",
			"std::vector<int> linear_congruence(long long a, long long c, int m) {",
			"    assert(m >= 1);",
			"    int u, v;",
			"    int g = extgcd<int>(a % m, m, u, v);       // g is gcd(a,m).",
			"    if(c % g != 0) return std::vector<int>();  // 解なし．",
			"    std::vector<int> res(g);",
			"    if(u < 0) u += m;  // 0≦u<m.",
			"    res[0] = c / g % m * u % m;",
			"    int dm = m / g;",
			"    for(int i = 1; i < g; ++i) {",
			"        long long tmp = (long long)res[i - 1] + dm;",
			"        if(tmp >= m) tmp -= m;",
			"        res[i] = tmp;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "一次合同式 ax≡c (mod m)"
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"// 最長増加部分列 (LIS: Longest Increasing Subsequence) の長さを求める．O(N*logN).",
			"template <typename Type, typename Func = std::function<bool(const Type &, const Type &)> >",
			"std::vector<int> lis(",
			"    const std::vector<Type> &v,",
			"    const Func &comp = [](const Type &a, const Type &b) -> bool { return a < b; }) {",
			"    const int n = v.size();",
			"    std::vector<int> res(n + 1, 0);  // res[i]:=(v[:i]における最長増加部分列の長さ).",
			"    std::vector<Type> sub;",
			"    sub.reserve(n);",
			"    for(int i = 0; i < n; ++i) {",
			"        auto itr = std::lower_bound(sub.begin(), sub.end(), v[i], comp);",
			"        if(itr == sub.end()) sub.push_back(v[i]);",
			"        else *itr = v[i];",
			"        res[i + 1] = sub.size();",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Longest Increasing Subsequence（最長増加部分列）"
	},
	"mod_inv": {
		"scope": "cpp",
		"prefix": "mod_inv",
		"body": [
			"// モジュラ逆数（乗法逆元）．",
			"// a^-1 mod m を求める．解が存在する必要十分条件は，aとmが互いに素であること．O(log a).",
			"template <typename Type>",
			"Type mod_inv(long long a, Type m) {",
			"    assert(m > 1);",
			"    long long b = m, u = 1, v = 0;",
			"    while(b != 0) {",
			"        long long t = a / b;",
			"        a -= b * t, u -= v * t;",
			"        std::swap(a, b), std::swap(u, v);",
			"    }",
			"    // assert((\"a and m need to be coprime.\", a == 1));",
			"    if(u < 0) u += m;",
			"    return u;",
			"}"
		],
		"description": "モジュラ逆数（乗法逆元）"
	},
	"mod_pow": {
		"scope": "cpp",
		"prefix": "mod_pow",
		"body": [
			"// 繰り返し二乗法（mod付き）．",
			"// a^k mod m を求める．O(logK).",
			"int mod_pow(long long a, long long k, int m) {",
			"    assert(k >= 0);",
			"    assert(m >= 1);",
			"    long long res = 1;",
			"    a %= m;",
			"    while(k > 0) {",
			"        if(k & 1LL) res = res * a % m;",
			"        a = a * a % m;",
			"        k >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "繰り返し二乗法（mod付き）"
	},
	"nPk, nCk, nHk": {
		"scope": "cpp",
		"prefix": "nPk, nCk, nHk",
		"body": [
			"// 順列．",
			"inline long long nPk(long long n, int k) {",
			"    assert(0 <= k and k <= n);",
			"    long long res = 1;",
			"    for(int i = 0; i < k; ++i) res = res * (n - i);",
			"    return res;",
			"}",
			"",
			"// 組合せ．",
			"inline long long nCk(long long n, int k) {",
			"    assert(0 <= k and k <= n);",
			"    long long res = 1;",
			"    for(int i = 0; i < k; ++i) res = res * (n - i) / (i + 1);",
			"    return res;",
			"}",
			"",
			"// 重複組合せ．",
			"inline long long nHk(int n, long long k) { return nCk(k + n - 1, n - 1); }"
		],
		"description": "順列，組合せ"
	},
	"prime_factorize": {
		"scope": "cpp",
		"prefix": "prime_factorize",
		"body": [
			"// 素因数分解．O(√N).",
			"template <typename Type>",
			"std::map<Type, int> prime_factorize(Type n) {",
			"    assert(n >= 0);",
			"    std::map<Type, int> res;  // res[p]:=(自然数nに含まれる素因数pの個数).",
			"    while(n % 2 == 0) res[2]++, n /= 2;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        while(n % p == 0) res[p]++, n /= p;",
			"    }",
			"    if(n > 1) res[n] = 1;",
			"    return res;",
			"}"
		],
		"description": "素因数分解"
	},
	"rotate": {
		"scope": "cpp",
		"prefix": "rotate",
		"body": [
			"// 2次元配列を時計回り90度回転させる．",
			"template <typename Type>",
			"std::vector<std::vector<Type> > rotate(const std::vector<std::vector<Type> > &v) {",
			"    assert(v.size() > 0);",
			"    const int h = v.size();",
			"    const int w = v[0].size();",
			"    std::vector<std::vector<Type> > res(w, std::vector<Type>(h));",
			"    for(int i = 0; i < w; ++i) {",
			"        for(int j = 0; j < h; ++j) res[i][j] = v[h - 1 - j][i];",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"run_length_encoding": {
		"scope": "cpp",
		"prefix": "run_length_encoding, rle",
		"body": [
			"// ランレングス圧縮（連長圧縮）．",
			"std::vector<std::pair<char, int> > run_length_encoding(const std::string &s) {",
			"    std::vector<std::pair<char, int> > res;",
			"    const int n = s.size();",
			"    if(n == 0) return res;",
			"    int cnt = 1;",
			"    for(int i = 1; i < n; ++i) {",
			"        if(s[i] != s[i - 1]) {",
			"            res.emplace_back(s[i - 1], cnt);",
			"            cnt = 0;",
			"        }",
			"        cnt++;",
			"    }",
			"    res.emplace_back(s[n - 1], cnt);",
			"    return res;",
			"}"
		],
		"description": "ランレングス圧縮（連長圧縮）"
	},
	"split": {
		"scope": "cpp",
		"prefix": "split",
		"body": [
			"// 文字列分割．文字列sを指定の文字delimで分割する．",
			"std::vector<std::string> split(const std::string &s, char delim, bool disable_empty = false) {",
			"    std::vector<std::string> res;",
			"    std::istringstream ss(s + delim);",
			"    std::string item;",
			"    while(std::getline(ss, item, delim)) {",
			"        if(!(item.empty() and disable_empty)) res.push_back(item);",
			"    }",
			"    return res;",
			"}",
			"",
			"// 文字列分割．文字列sを指定の文字列delimで分割する．",
			"std::vector<std::string> split(const std::string &s, const std::string &delim, bool disable_empty = false) {",
			"    std::vector<std::string> res;",
			"    const size_t length = delim.size();",
			"    size_t offset = 0;",
			"    while(true) {",
			"        size_t pos = s.find(delim, offset);",
			"        if(pos == std::string::npos) {",
			"            std::string &&item = s.substr(offset);",
			"            if(!(item.empty() and disable_empty)) res.push_back(item);",
			"            break;",
			"        }",
			"        std::string &&item = s.substr(offset, pos - offset);",
			"        if(!(item.empty() and disable_empty)) res.push_back(item);",
			"        offset = pos + length;",
			"    }",
			"    return res;",
			"}",
			"",
			"// 文字列分割．文字列sを正規表現patternにマッチする文字列で分割する．",
			"std::vector<std::string> split_re(const std::string &s, const std::regex &pattern, bool disable_empty = false) {",
			"    std::vector<std::string> res;",
			"    std::sregex_token_iterator itr(s.begin(), s.end(), pattern, -1);",
			"    std::sregex_token_iterator end;",
			"    for(; itr != end; ++itr) {",
			"        if(!((*itr).str().empty() and disable_empty)) res.push_back(*itr);",
			"    }",
			"    return res;",
			"}"
		],
		"description": "文字列分割"
	},
	"string_modulo": {
		"scope": "cpp",
		"prefix": "string_modulo",
		"body": [
			"// 文字列剰余．O(|S|).",
			"template <typename Type>",
			"Type string_modulo(const std::string &s, const Type mod) {",
			"    const int n = s.size();",
			"    long long res = 0;",
			"    for(int i = 0; i < n; ++i) {",
			"        assert('0' <= s[i] and s[i] <= '9');",
			"        res = (10 * res + (s[i] - '0')) % mod;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "文字列剰余"
	},
	"totient": {
		"scope": "cpp",
		"prefix": "totient",
		"body": [
			"// オイラーのファイ関数．",
			"// n以下でnと互いに素な自然数の個数を求める．O(√N).",
			"template <typename Type>",
			"Type totient(Type n) {",
			"    assert(n >= 1);",
			"    Type res = n;",
			"    for(Type p = 2; p * p <= n; ++p) {",
			"        if(n % p == 0) {",
			"            res -= res / p;",
			"            while(n % p == 0) n /= p;",
			"        }",
			"    }",
			"    if(n > 1) res -= res / n;",
			"    return res;",
			"}"
		],
		"description": "オイラーのファイ関数"
	},
	"z_algorithm": {
		"scope": "cpp",
		"prefix": "z_algorithm",
		"body": [
			"// 最長共通接頭辞 (LCP: Longest Common Prefix) の長さを求める．",
			"// 引数はSTLのシーケンスコンテナ．O(|S|).",
			"template <class Sequence>",
			"std::vector<int> z_algorithm(const Sequence &s) {",
			"    const int n = s.size();",
			"    std::vector<int> z(n + 1, 0);  // z[i]:=(sとs[i:]のLCPの長さ).",
			"    z[0] = n;",
			"    int i = 1, j = 0;",
			"    while(i < n) {",
			"        while(i + j < n and s[j] == s[i + j]) j++;",
			"        z[i] = j;",
			"        if(j == 0) {",
			"            i++;",
			"            continue;",
			"        }",
			"        int k = 1;",
			"        while(i + k < n and k + z[k] < j) {",
			"            z[i + k] = z[k];",
			"            k++;",
			"        }",
			"        i += k, j -= k;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "Longest Common Prefix（最長共通接頭辞）"
	},
	"namespace geometry (Vector)": {
		"scope": "cpp",
		"prefix": "namespace geometry (Vector)",
		"body": [
			"namespace geometry {",
			"",
			"using Type = double;",
			"",
			"const Type INF = 1e18;",
			"const Type EPS = 1e-10;",
			"const Type PI = std::acos(-1.0);",
			"",
			"inline bool equal_to(const Type &a, const Type &b) { return std::abs(a - b) < EPS; }",
			"inline bool less_than(const Type &a, const Type &b) { return a - b < -EPS; }",
			"inline bool more_than(const Type &a, const Type &b) { return a - b > EPS; }",
			"inline bool no_more(const Type &a, const Type &b) { return a - b < EPS; }",
			"inline bool no_less(const Type &a, const Type &b) { return a - b > -EPS; }",
			"",
			"// 角度を弧度法に変換する．",
			"inline Type to_radian(Type deg) { return deg / 180.0 * PI; }",
			"// 角度を度数法に変換する．",
			"inline Type to_degree(Type rad) { return rad / PI * 180.0; }",
			"",
			"struct Vector {",
			"    Type x, y;",
			"",
			"    Vector() : Vector(0.0, 0.0) {}",
			"    Vector(Type x_, Type y_) : x(x_), y(y_) {}",
			"",
			"    Vector operator+() const { return Vector(*this); }",
			"    Vector operator-() const { return Vector(-x, -y); }",
			"    Vector operator*(Type n) const { return Vector(x * n, y * n); }",
			"    Vector operator/(Type n) const { return Vector(x / n, y / n); }",
			"    Vector &operator*=(Type n) {",
			"        x *= n, y *= n;",
			"        return *this;",
			"    }",
			"    Vector &operator/=(Type n) {",
			"        x /= n, y /= n;",
			"        return *this;",
			"    }",
			"    Vector &operator+=(const Vector &a) {",
			"        x += a.x, y += a.y;",
			"        return *this;",
			"    }",
			"    Vector &operator-=(const Vector &a) {",
			"        x -= a.x, y -= a.y;",
			"        return *this;",
			"    }",
			"",
			"    friend Vector operator*(Type n, const Vector &a) { return a * n; }",
			"    friend Vector operator+(const Vector &a, const Vector &b) { return Vector(a.x + b.x, a.y + b.y); }",
			"    friend Vector operator-(const Vector &a, const Vector &b) { return Vector(a.x - b.x, a.y - b.y); }",
			"    friend bool operator<(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? less_than(a.y, b.y) : less_than(a.x, b.x)); }",
			"    friend bool operator>(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? more_than(a.y, b.y) : more_than(a.x, b.x)); }",
			"    friend bool operator<=(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? no_more(a.y, b.y) : no_more(a.x, b.x)); }",
			"    friend bool operator>=(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) ? no_less(a.y, b.y) : no_less(a.x, b.x)); }",
			"    friend bool operator==(const Vector &a, const Vector &b) { return (equal_to(a.x, b.x) and equal_to(a.y, b.y)); }",
			"    friend bool operator!=(const Vector &a, const Vector &b) { return !(a == b); }",
			"    friend std::ostream &operator<<(std::ostream &os, const Vector &a) { return os << \"(\" << a.x << \", \" << a.y << \")\"; }",
			"",
			"    // ノルム．",
			"    Type norm() const { return std::sqrt(dot(*this, *this)); }",
			"    // x軸となす角．[-π,π].",
			"    Type arg() const { return std::atan2(y, x); }",
			"    // x軸となす角．[0,2π).",
			"    Type arg2() const {",
			"        auto res = arg();",
			"        if(less_than(res, 0.0)) res += 2 * PI;",
			"        return res;",
			"    }",
			"    // 反時計回りに角度arg（ラジアン単位）回転したベクトル．",
			"    Vector rotate(Type arg) const {",
			"        Type nx = x * std::cos(arg) - y * std::sin(arg);",
			"        Type ny = x * std::sin(arg) + y * std::cos(arg);",
			"        return Vector(nx, ny);",
			"    }",
			"    // 反時計回りに90度回転したベクトル．",
			"    Vector rotate90() const { return Vector(-y, x); }",
			"    // 180度回転したベクトル．",
			"    Vector rotate180() const { return Vector(-x, -y); }",
			"    // 単位ベクトル．",
			"    Vector unit() const { return *this / norm(); }",
			"",
			"    // 内積．",
			"    friend inline Type dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y; }",
			"    // 外積．",
			"    friend inline Type cross(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x; }",
			"};",
			"",
			"using Point = Vector;",
			"using Polygon = std::vector<Point>;",
			"",
			"// 反時計回りに角度arg（ラジアン単位）回転させる．",
			"void rotate(Vector &a, Type arg) {",
			"    Type nx = a.x * std::cos(arg) - a.y * std::sin(arg);",
			"    Type ny = a.x * std::sin(arg) + a.y * std::cos(arg);",
			"    a.x = nx, a.y = ny;",
			"}",
			"// 反時計周りに90度回転させる．",
			"inline void rotate90(Vector &a) {",
			"    auto tmp = a.x;",
			"    a.x = -a.y;",
			"    a.y = tmp;",
			"}",
			"// 反時計周りに180度回転させる．",
			"inline void rotate180(Vector &a) { a.x = -a.x, a.y = -a.y; }",
			"",
			"// 2点間距離を計算する．",
			"inline Type distance(const Point &P, const Point &Q) { return (Q - P).norm(); }",
			"",
			"// 3点の位置関係．",
			"int simple_ccw(const Point &A, const Point &B, const Point &P) {",
			"    Vector b = B - A, p = P - A;",
			"    if(more_than(cross(b, p), 0.0)) return 1;   // A->Bの反時計方向にP．",
			"    if(less_than(cross(b, p), 0.0)) return -1;  // A->Bの時計方向にP．",
			"    return 0;                                   // 一直線上．",
			"}",
			"int ccw(const Point &A, const Point &B, const Point &P) {",
			"    Vector b = B - A, p = P - A;",
			"    if(more_than(cross(b, p), 0.0)) return 1;      // A->Bの反時計方向にP．counter clockwise.",
			"    if(less_than(cross(b, p), 0.0)) return -1;     // A->Bの時計方向にP．clockwise.",
			"    if(less_than(dot(b, p), 0.0)) return -2;       // P->A->Bの順に一直線上．online back.",
			"    if(more_than(dot(p, p), dot(b, b))) return 2;  // A->B->Pの順に一直線上．online front.",
			"    return 0;                                      // A->P->Bの順に一直線上．on segment.",
			"}",
			"",
			"// 三角形と点の包含関係．",
			"int contain(const Point &A, const Point &B, const Point &C, const Point &P) {",
			"    int flag1 = ccw(A, B, P), flag2 = ccw(B, C, P), flag3 = ccw(C, A, P);",
			"    if(flag1 == 0 or flag2 == 0 or flag3 == 0) return 1;       // on.",
			"    if(flag1 == -1 and flag2 == -1 and flag3 == -1) return 2;  // in.",
			"    if(flag1 == 1 and flag2 == 1 and flag3 == 1) return 2;     // in.",
			"    return 0;                                                  // out.",
			"}",
			"",
			"// 複素数．",
			"struct Complex : public Point {",
			"    Complex() : Point() {}",
			"    Complex(const Point &P) : Point(P) {}",
			"    Complex(Type x_, Type y_) : Point(x_, y_) {}",
			"",
			"    Complex &operator*=(const Complex &z) {",
			"        const auto [tx, ty] = *this;",
			"        x = tx * z.x - ty * z.y;",
			"        y = tx * z.y + ty * z.x;",
			"        return *this;",
			"    }",
			"    Complex &operator/=(const Complex &z) {",
			"        const auto [tx, ty] = *this;",
			"        x = tx * z.x - ty * z.y;",
			"        y = tx * z.y + ty * z.x;",
			"        return *this;",
			"    }",
			"",
			"    friend Complex operator*(const Complex &z, const Complex &w) { return Complex(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }",
			"    friend Complex operator/(const Complex &z, const Complex &w) { return Complex(z / (w.x * w.x + w.y * w.y)) * w; }",
			"",
			"    // 共役複素数．Conjugate complex number.",
			"    Complex conj() const { return Complex(x, -y); }",
			"};",
			"",
			"// 極形式．大きさr，偏角argの複素数を返す．",
			"inline Complex polar(Type r, Type arg) { return Complex(r * std::cos(arg), r * std::sin(arg)); }",
			"// 極形式(r,θ)に変換する．θ∈[-π,π].",
			"inline std::pair<Type, Type> convert_polor(const Complex &z) { return {z.norm(), z.arg()}; }",
			"// 極形式(r,θ)に変換する．θ∈[0,2π).",
			"inline std::pair<Type, Type> convert_polor2(const Complex &z) { return {z.norm(), z.arg2()}; }",
			"",
			"}  // namespace geometry",
			"",
			"// using namespace geometry;"
		],
		"description": ""
	},
	"namespace geometry (Line)": {
		"scope": "cpp",
		"prefix": "namespace geometry (Line)",
		"body": [
			"namespace geometry {",
			"",
			"// 直線．",
			"struct Line {",
			"    std::array<Point, 2> ps;",
			"",
			"    Line() : Line(Point(), Point()) {}",
			"    explicit Line(const Point &P, const Point &Q) : ps({P, Q}) {}",
			"",
			"    Point &operator[](int i) {",
			"        assert(0 <= i and i < 2);",
			"        return ps[i];",
			"    }",
			"    const Point &operator[](int i) const {",
			"        assert(0 <= i and i < 2);",
			"        return ps[i];",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const Line &s) { return os << \"{\" << s[0] << \", \" << s[1] << \"}\"; }",
			"",
			"    // 傾き．",
			"    Type slope() const { return (ps[1].y - ps[0].y) / (ps[1].x - ps[0].x); }",
			"    // y切片．",
			"    Type y_intercept() const { return ps[0].y - slope() * ps[0].x; }",
			"    // x切片．",
			"    Type x_intercept() const { return ps[0].x - ps[0].y / slope(); }",
			"    bool on_line(const Point &P) const { return equal_to(cross(ps[1] - ps[0], P - ps[0]), 0.0); }",
			"};",
			"",
			"// 線分．",
			"struct Segment : public Line {",
			"    Segment() : Line() {}",
			"    Segment(const Line &l) : Line(l) {}",
			"    explicit Segment(const Point &P, const Point &Q) : Line(P, Q) {}",
			"",
			"    // 線分の長さ．",
			"    Type length() const { return distance(ps[0], ps[1]); }",
			"    bool on_segment(const Point &P) const {",
			"        Vector b = ps[1] - ps[0], p = P - ps[0];",
			"        if(!equal_to(cross(b, p), 0.0)) return false;",
			"        return (no_less(dot(b, p), 0.0) and no_more(dot(p, p), dot(b, b)));",
			"    }",
			"};",
			"",
			"// 直線の直交判定．",
			"bool jud_orthogonal(const Line &l, const Line &m) {",
			"    Vector b = l[1] - l[0], d = m[1] - m[0];",
			"    return equal_to(dot(b, d), 0.0);",
			"}",
			"// 直線の平行判定．",
			"bool jud_parallel(const Line &l, const Line &m) {",
			"    Vector b = l[1] - l[0], d = m[1] - m[0];",
			"    return equal_to(cross(b, d), 0.0);",
			"}",
			"// 直線の交差判定．",
			"bool jud_intersection(const Line &l, const Line &m) { return !jud_parallel(l, m); }",
			"// 直線と線分の交差判定．",
			"bool jud_intersection(const Line &l, const Segment &m) {",
			"    Vector b = l[1] - l[0];",
			"    auto s = cross(b, m[0] - l[0]);",
			"    auto t = cross(b, m[1] - l[0]);",
			"    return no_more(s * t, 0.0);",
			"}",
			"bool jud_intersection(const Segment &l, const Line &m) { return jud_intersection(m, l); }",
			"// 線分の交差判定．",
			"bool jud_intersection(const Segment &l, const Segment &m) {",
			"    Vector b = l[1] - l[0], d = m[1] - m[0];",
			"    auto s = cross(b, m[0] - l[0]);",
			"    auto t = cross(b, m[1] - l[0]);",
			"    if(more_than(s * t, 0.0)) return false;",
			"    s = cross(d, l[0] - m[0]);",
			"    t = cross(d, l[1] - m[0]);",
			"    if(more_than(s * t, 0.0)) return false;",
			"    return true;",
			"}",
			"",
			"// 2直線の交点．",
			"Point intersection(const Line &l, const Line &m) {",
			"    Vector b = l[1] - l[0], d = m[1] - m[0];",
			"    auto s = cross(m[0] - l[0], d) / cross(b, d);",
			"    return Point(l[0] + s * b);",
			"    // auto t = cross(b, l[0] - m[0]) / cross(b, d);",
			"    // return Point(m[0] + t * d);",
			"}",
			"",
			"// 垂線の足．",
			"Point projection(const Line &l, const Point &P) {",
			"    Vector a = l[1] - l[0];",
			"    return l[0] + a * (dot(P - l[0], a) / dot(a, a));",
			"}",
			"// 対象点．",
			"Point reflection(const Line &l, const Point &P) {",
			"    Point H = projection(l, P);",
			"    return P + 2 * (H - P);",
			"}",
			"",
			"// 点と線の距離．",
			"Type distance(const Line &l, const Point &P) {",
			"    Point H = projection(l, P);",
			"    return distance(P, H);",
			"}",
			"Type distance(const Point &P, const Line &l) { return distance(l, P); }",
			"Type distance(const Segment &s, const Point &P) {",
			"    Point H = projection(s, P);",
			"    if(s.on_segment(H)) return distance(H, P);",
			"    return std::min(distance(P, s[0]), distance(P, s[1]));",
			"}",
			"Type distance(const Point &P, const Segment &s) { return distance(s, P); }",
			"",
			"}  // namespace geometry",
			"",
			"// using namespace geometry;"
		],
		"description": ""
	},
	"namespace geometry (Figure)": {
		"scope": "cpp",
		"prefix": "namespace geometry (Figure)",
		"body": [
			"namespace geometry {",
			"",
			"// 長方形．",
			"struct Box {",
			"    std::array<Point, 2> ps;",
			"",
			"    // constructor. 2点を対角とする長方形を定義する．",
			"    Box() : Box(Point(), Point(1, 1)) {}",
			"    explicit Box(const Point &P, const Point &Q) {",
			"        ps[0].x = std::min<Type>(P.x, Q.x);",
			"        ps[0].y = std::min<Type>(P.y, Q.y);",
			"        ps[1].x = std::max<Type>(P.x, Q.x);",
			"        ps[1].y = std::max<Type>(P.y, Q.y);",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const Box &box) {",
			"        return os << \"{\" << Point(box.ps[0].x, box.ps[1].y) << \", \" << box.ps[0]",
			"                  << \", \" << Point(box.ps[1].x, box.ps[0].y) << \", \" << box.ps[1] << \"}\";",
			"    }",
			"",
			"    // 面積．",
			"    Type area() const { return (ps[1].x - ps[0].x) * (ps[1].y - ps[0].y); }",
			"    int contain(const Point &P) const {",
			"        if(less_than(ps[0].x, P.x) and less_than(P.x, ps[1].x) and less_than(ps[0].y, P.y) and less_than(P.y, ps[1].y)) return 2;  // in.",
			"        if(no_more(ps[0].x, P.x) and no_more(P.x, ps[1].x) and no_more(ps[0].y, P.y) and no_more(P.y, ps[1].y)) return 1;          // on.",
			"        return 0;                                                                                                                  // out.",
			"    }",
			"};",
			"",
			"// 円形．",
			"struct Circle {",
			"    Point O;",
			"    Type r;",
			"",
			"    Circle() : O(Point()), r(1.0) {}",
			"    explicit Circle(Type r_) : O(Point()), r(r_) {}",
			"    explicit Circle(const Point &C_, Type r_) : O(C_), r(r_) {}",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const Circle &C) { return os << \"{O\" << C.O << \", r = \" << C.r << \"}\"; }",
			"",
			"    // 円周の長さ．",
			"    Type length() const { return 2 * r * PI; }",
			"    // 面積．",
			"    Type area() const { return r * r * PI; }",
			"    int contain(const Point &P) const {",
			"        if(less_than(distance(O, P), r)) return 2;  // in.",
			"        if(no_more(distance(O, P), r)) return 1;    // on.",
			"        return 0;                                   // out.",
			"    }",
			"};",
			"",
			"// 2点からの距離の比率がm:nであるアポロニウスの円．",
			"Circle apporonius(const Point &A, const Point &B, Type m, Type n) {",
			"    assert(!equal_to(m, n));",
			"    Point P = (n * A + m * B) / (m + n);",
			"    Point Q = (-n * A + m * B) / (m - n);",
			"    Point O = (P + Q) / 2;",
			"    Type r = (P - O).norm();",
			"    return Circle(O, r);",
			"}",
			"",
			"// 円と直線の交点．",
			"std::vector<Point> intersection(const Circle &C, const Line &l) {",
			"    std::vector<Point> res;",
			"    Point H = projection(l, C.O);",
			"    auto flag = C.contain(H);",
			"    if(flag == 1) {",
			"        res.push_back(H);",
			"    } else if(flag == 2) {",
			"        auto dist = distance(C.O, H);",
			"        auto arg = std::acos(dist / C.r);",
			"        Vector a = H - C.O;",
			"        res.push_back(C.O + a.rotate(-arg));",
			"        res.push_back(C.O + a.rotate(arg));",
			"    }",
			"    return res;",
			"}",
			"// 円と円の交点．",
			"std::vector<Point> intersection(Circle C, Circle D) {",
			"    std::vector<Point> res;",
			"    if(less_than(C.r, D.r)) std::swap(C, D);",
			"    auto dist = distance(C.O, D.O);",
			"    if(more_than(dist, C.r + D.r)) {  // 離れている場合．",
			"        // No points.",
			"    } else if(equal_to(dist, C.r + D.r)) {  // 外接する場合．",
			"        Vector a = (D.O - C.O).unit() * C.r;",
			"        res.push_back(C.O + a);",
			"    } else if(more_than(dist, std::abs(C.r - D.r))) {  // 交差する場合．",
			"        auto arg = std::acos((C.r * C.r + dist * dist - D.r * D.r) / (2 * C.r * dist));",
			"        Vector a = (D.O - C.O).unit() * C.r;",
			"        res.push_back(C.O + a.rotate(-arg));",
			"        res.push_back(C.O + a.rotate(arg));",
			"    } else if(equal_to(dist, C.r - D.r)) {  // 内接する場合．",
			"        Vector a = (D.O - C.O).unit() * C.r;",
			"        res.push_back(C.O + a);",
			"    } else {  // 内部にある場合．",
			"        // No points.",
			"    }",
			"    return res;",
			"}",
			"",
			"// 三角形の面積．",
			"Type area(const Point &A, const Point &B, const Point &C) { return std::abs(cross(B - A, C - A)) / 2; }",
			"// 多角形の面積．O(N).",
			"Type area(const Polygon &pol) {",
			"    const int n = pol.size();",
			"    Type res = 0.0;",
			"    for(int i = 0; i < n; ++i) res += cross(pol[i], pol[(i + 1) % n]);",
			"    return res / 2;",
			"}",
			"",
			"// 多角形と点の包含関係．O(N).",
			"int contain(const Polygon &pol, const Point &P) {",
			"    const int n = pol.size();",
			"    Type sum = 0.0;",
			"    for(int i = 0; i < n; ++i) {",
			"        if(Segment(pol[i], pol[(i + 1) % n]).on_segment(P)) return 1;  // on.",
			"        Vector a = pol[i] - P, b = pol[(i + 1) % n] - P;",
			"        auto arg = std::acos(dot(a, b) / a.norm() / b.norm());",
			"        if(less_than(cross(a, b), 0.0)) sum -= arg;",
			"        else sum += arg;",
			"    }",
			"    if(equal_to(sum, 0.0)) return 0;  // out. sum==0.",
			"    return 2;                         // in. sum==2*PI.",
			"}",
			"",
			"// 偏角ソート．点を反時計回りにソートする．O(NlogN).",
			"void argument_sort(Polygon &pol) {",
			"    auto comp = [](const Vector &p, const Vector &q) -> bool {",
			"        return p.arg() < q.arg();",
			"    };",
			"    std::sort(pol.begin(), pol.end(), comp);",
			"}",
			"",
			"// 凸性判定．O(N). 多角形の頂点は反時計回りに並んでいること．",
			"bool is_convex(const Polygon &pol) {",
			"    const int n = pol.size();",
			"    for(int i = 0; i < n; ++i) {",
			"        if(simple_ccw(pol[i], pol[(i + 1) % n], pol[(i + 2) % n]) == -1) return false;",
			"    }",
			"    return true;",
			"}",
			"",
			"// アンドリューのアルゴリズム．凸包．O(N*logN).",
			"Polygon andrew_scan(Polygon pol, bool is_strong = true) {",
			"    const auto cmp = (is_strong ? geometry::EPS : -geometry::EPS);",
			"    const int n = pol.size();",
			"    Polygon res(2 * n);",
			"    int k = 0;",
			"    std::sort(pol.begin(), pol.end());",
			"    for(int i = 0; i < n; ++i) {",
			"        while(k >= 2 and cross(res[k - 1] - res[k - 2], pol[i] - res[k - 2]) < cmp) k--;",
			"        res[k++] = pol[i];",
			"    }",
			"    int t = k + 1;",
			"    for(int i = n - 2; i >= 0; --i) {",
			"        while(k >= t and cross(res[k - 1] - res[k - 2], pol[i] - res[k - 2]) < cmp) k--;",
			"        res[k++] = pol[i];",
			"    }",
			"    res.resize(k - 1);",
			"    return res;",
			"}",
			"",
			"// 凸多角形の切断．O(N).",
			"Polygon convex_cut(const Polygon &pol, const Line &l) {",
			"    assert(is_convex(pol));",
			"    const int n = pol.size();",
			"    Polygon res;",
			"    for(int i = 0; i < n; ++i) {",
			"        const Point &P = pol[i];",
			"        const Point &Q = pol[(i + 1) % n];",
			"        if(simple_ccw(l[0], l[1], P) != -1) {",
			"            if(res.size() == 0 or P != *res.rbegin()) res.push_back(P);",
			"        }",
			"        if(simple_ccw(l[0], l[1], P) * simple_ccw(l[0], l[1], Q) < 0) {",
			"            Point R = intersection(Line(P, Q), l);",
			"            res.push_back(R);",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"}  // namespace geometry",
			"",
			"// using namespace geometry;"
		],
		"description": ""
	},
	"namespace matrix": {
		"scope": "cpp",
		"prefix": "namespace matrix",
		"body": [
			"namespace matrix {",
			"",
			"using Type = double;",
			"",
			"constexpr Type EPS = 1e-10;",
			"",
			"template <typename T>",
			"class Matrix {",
			"    int m_col;",
			"    int m_row;",
			"    std::vector<std::vector<T> > m_dat;",
			"    bool m_is_transposed;",
			"",
			"public:",
			"    Matrix() : Matrix(0, 0) {}",
			"    explicit Matrix(int m, int n) : m_col(m), m_row(n), m_dat(m, std::vector<T>(n)), m_is_transposed(false) {}",
			"    explicit Matrix(int m, int n, T val) : m_col(m), m_row(n), m_dat(m, std::vector<T>(n, val)), m_is_transposed(false) {}",
			"    explicit Matrix(const std::vector<std::vector<T> > &val) : m_col(val.size()), m_row(0), m_dat(val), m_is_transposed(false) {",
			"        for(const auto &v : m_dat) m_row = std::max(m_row, static_cast<int>(v.size()));",
			"        for(auto &v : m_dat) v.resize(m_row, 0);",
			"    }",
			"",
			"    Matrix operator+() const { return Matrix(*this); }",
			"    Matrix operator-() const {",
			"        Matrix R(*this);",
			"        for(auto &v : R.m_dat) {",
			"            for(auto &elem : v) elem = -elem;",
			"        }",
			"        return R;",
			"    }",
			"    Matrix &operator*=(T a) {",
			"        for(auto &v : m_dat) {",
			"            for(auto &elem : v) elem *= a;",
			"        }",
			"        return *this;",
			"    }",
			"    Matrix &operator/=(T a) {",
			"        for(auto &v : m_dat) {",
			"            for(auto &elem : v) elem /= a;",
			"        }",
			"        return *this;",
			"    }",
			"    Matrix &operator+=(const Matrix &A) {",
			"        assert(A.column() == column() and A.row() == row());",
			"        for(int i = 0; i < column(); ++i) {",
			"            for(int j = 0; j < row(); ++j) loc(i, j) += A.loc(i, j);",
			"        }",
			"        return *this;",
			"    }",
			"    Matrix &operator-=(const Matrix &A) {",
			"        assert(A.column() == column() and A.row() == row());",
			"        for(int i = 0; i < column(); ++i) {",
			"            for(int j = 0; j < row(); ++j) loc(i, j) -= A.loc(i, j);",
			"        }",
			"        return *this;",
			"    }",
			"    Matrix operator*(T a) const {",
			"        Matrix R(*this);",
			"        R *= a;",
			"        return R;",
			"    }",
			"    Matrix operator/(T a) const {",
			"        Matrix R(*this);",
			"        R /= a;",
			"        return R;",
			"    }",
			"    Matrix operator*(const Matrix &A) const {",
			"        assert(row() == A.column());",
			"        Matrix R(column(), A.row(), 0);",
			"        for(int i = 0; i < column(); ++i) {",
			"            for(int j = 0; j < A.row(); ++j) {",
			"                for(int k = 0; k < row(); ++k) R.loc(i, j) += loc(i, k) * A.loc(k, j);",
			"            }",
			"        }",
			"        return R;",
			"    }",
			"    Matrix operator+(const Matrix<T> &A) const {",
			"        assert(A.column() == column() and A.row() == row());",
			"        Matrix R(*this);",
			"        R += A;",
			"        return R;",
			"    }",
			"    Matrix operator-(const Matrix<T> &A) const {",
			"        assert(A.column() == column() and A.row() == row());",
			"        Matrix R(*this);",
			"        R -= A;",
			"        return R;",
			"    }",
			"    bool operator==(const Matrix<T> &A) const {",
			"        assert(A.column() == column() and A.row() == row());",
			"        for(int i = 0; i < column(); ++i) {",
			"            for(int j = 0; j < row(); ++j) {",
			"                if(loc(i, j) != A.loc(i, j)) return false;",
			"            }",
			"        }",
			"        return true;",
			"    }",
			"    bool operator!=(const Matrix<T> &A) const { return !(*this == A); }",
			"",
			"    friend Matrix operator*(T a, const Matrix &A) { return A * a; }",
			"    friend std::ostream &operator<<(std::ostream &os, const Matrix<T> &A) {",
			"        for(int i = 0; i < A.column(); ++i) {",
			"            for(int j = 0; j < A.row(); ++j) os << (i == 0 and j == 0 ? \"[\" : \" \") << A.loc(i, j);",
			"            os << (i == A.column() - 1 ? \"]\" : \"\\n\");",
			"        }",
			"        return os;",
			"    }",
			"",
			"    // 零行列．",
			"    static Matrix zero_matrix(int m, int n) {",
			"        assert(m >= 0 and n >= 0);",
			"        Matrix O(m, n, 0);",
			"        return O;",
			"    }",
			"    // 単位行列．",
			"    static Matrix identity_matrix(int n) {",
			"        assert(n >= 0);",
			"        Matrix I(n, n, 0);",
			"        for(int i = 0; i < n; ++i) I.loc(i, i) = 1;",
			"        return I;",
			"    }",
			"",
			"    // 行数．",
			"    int column() const { return (m_is_transposed ? m_row : m_col); }",
			"    // 列数．",
			"    int row() const { return (m_is_transposed ? m_col : m_row); }",
			"    const T &loc(int i, int j) const {",
			"        assert(0 <= i and i < column());",
			"        assert(0 <= j and j < row());",
			"        return (m_is_transposed ? m_dat[j][i] : m_dat[i][j]);",
			"    }",
			"    T &loc(int i, int j) {",
			"        assert(0 <= i and i < column());",
			"        assert(0 <= j and j < row());",
			"        return (m_is_transposed ? m_dat[j][i] : m_dat[i][j]);",
			"    }",
			"    // 転置．",
			"    void transpose() { m_is_transposed = !m_is_transposed; }",
			"    // 行・列の入れ替え．",
			"    void swap(int p, int q, int axis = 0) {",
			"        if(axis == 0) {",
			"            assert(0 <= p and p < column());",
			"            assert(0 <= q and q < column());",
			"            if(p == q) return;",
			"            for(int j = 0; j < row(); ++j) std::swap(loc(p, j), loc(q, j));",
			"        } else {",
			"            assert(0 <= p and p < row());",
			"            assert(0 <= q and q < row());",
			"            if(p == q) return;",
			"            for(int i = 0; i < column(); ++i) std::swap(loc(i, p), loc(i, q));",
			"        }",
			"    }",
			"};",
			"",
			"using mat = Matrix<Type>;",
			"",
			"// 転置行列．",
			"template <typename T>",
			"inline Matrix<T> transposed_matrix(const Matrix<T> &A) {",
			"    Matrix<T> tA(A);",
			"    tA.transpose();",
			"    return tA;",
			"}",
			"",
			"// 回転行列．",
			"inline mat rotation_matrix(Type arg) {",
			"    auto sv = std::sin(arg);",
			"    auto cv = std::cos(arg);",
			"    mat rot({{cv, -sv}, {sv, cv}});",
			"    return rot;",
			"}",
			"",
			"// 行列累乗．O((logK)*N^3)",
			"template <typename T>",
			"Matrix<T> pow(const Matrix<T> &A, long long k, bool right_side = false) {",
			"    assert(A.row() == A.column() and k >= 0);",
			"    auto &&R = Matrix<T>::identity_matrix(A.column());",
			"    auto B = A;",
			"    while(k > 0) {",
			"        if(k & 1) R = (right_side ? R * B : B * R);",
			"        B = B * B;",
			"        k >>= 1;",
			"    }",
			"    return R;",
			"}",
			"",
			"// 置換．",
			"class Permutation {",
			"    int m_n;                  // m_n:=(次数).",
			"    std::vector<int> m_perm;  // m_perm[]:=(置換).",
			"    std::vector<int> m_inv;   // m_inv[]:=(逆置換). m_inv[m_perm[i]]==i",
			"    bool m_is_inversed;",
			"",
			"public:",
			"    Permutation() : Permutation(0) {}",
			"    explicit Permutation(int n) : m_n(n), m_perm(n), m_inv(n), m_is_inversed(false) {",
			"        std::iota(m_perm.begin(), m_perm.end(), 0);",
			"        std::iota(m_inv.begin(), m_inv.end(), 0);",
			"    }",
			"    explicit Permutation(int n, const std::vector<int> &cycle) : Permutation(n, std::vector<std::vector<int> >(1, cycle)) {}",
			"    explicit Permutation(int n, const std::vector<std::vector<int> > &cycles) : m_n(n), m_perm(n, -1), m_inv(n), m_is_inversed(false) {",
			"        for(const auto &cycle : cycles) {",
			"            const int n = static_cast<int>(cycle.size());",
			"            for(int i = 0; i < n; ++i) {",
			"                assert(0 <= cycle[i] and cycle[i] < m_n);",
			"                assert(m_perm[cycle[i]] == -1);",
			"                m_perm[cycle[i]] = cycle[(i + 1) % n];",
			"            }",
			"        }",
			"        for(int i = 0; i < m_n; ++i) {",
			"            if(m_perm[i] == -1) m_perm[i] = i;",
			"        }",
			"        for(int i = 0; i < m_n; ++i) m_inv[m_perm[i]] = i;",
			"    }",
			"    explicit Permutation(const std::vector<int> &perm) : m_n(perm.size()), m_perm(perm), m_inv(perm.size(), -1), m_is_inversed(false) {",
			"        for(int i = 0; i < m_n; ++i) {",
			"            assert(0 <= m_perm[i] and m_perm[i] < m_n);",
			"            assert(m_inv[m_perm[i]] == -1);",
			"            m_inv[m_perm[i]] = i;",
			"        }",
			"    }",
			"",
			"    // 置換．",
			"    const int &operator[](int i) const {",
			"        assert(0 <= i and i < order());",
			"        return (m_is_inversed ? m_inv[i] : m_perm[i]);",
			"    }",
			"    // 置換の積．",
			"    Permutation operator*(const Permutation &P) {",
			"        assert(P.order() == order());",
			"        std::vector<int> res(order());",
			"        for(int i = 0; i < order(); ++i) res[i] = (*this)[P[i]];",
			"        return Permutation(res);",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const Permutation &P) {",
			"        for(int i = 0; i < P.order(); ++i) os << (i == 0 ? \"[\" : \" \") << i;",
			"        os << \"\\n\";",
			"        for(int i = 0; i < P.order(); ++i) os << \" \" << P[i];",
			"        os << \"]\";",
			"        return os;",
			"    }",
			"",
			"    // 次数．",
			"    int order() const { return m_n; }",
			"    // 逆置換．",
			"    const int &inv(int i) const {",
			"        assert(0 <= i and i < order());",
			"        return (m_is_inversed ? m_perm[i] : m_inv[i]);",
			"    }",
			"    void swap(int i, int j) {",
			"        assert(0 <= i and i < order());",
			"        assert(0 <= j and j < order());",
			"        if(m_is_inversed) {",
			"            std::swap(m_inv[i], m_inv[j]);",
			"            m_perm[m_inv[i]] = i;",
			"            m_perm[m_inv[j]] = j;",
			"        } else {",
			"            std::swap(m_perm[i], m_perm[j]);",
			"            m_inv[m_perm[i]] = i;",
			"            m_inv[m_perm[j]] = j;",
			"        }",
			"    }",
			"    void inverse() { m_is_inversed = !m_is_inversed; }",
			"    template <class Sequence>",
			"    void sort(Sequence &a) const {",
			"        assert(static_cast<int>(a.size()) == order());",
			"        bool seen[order()] = {};",
			"        for(int i = 0; i < order(); ++i) {",
			"            if(seen[i]) continue;",
			"            int idx = inv(i);",
			"            while(idx != i) {",
			"                std::swap(a[i], a[idx]);",
			"                seen[idx] = true;",
			"                idx = inv(idx);",
			"            }",
			"            seen[i] = true;",
			"        }",
			"    }",
			"    template <class Sequence>",
			"    void reverse(Sequence &a) {",
			"        inverse();",
			"        sort(a);",
			"        inverse();",
			"    }",
			"    // 巡回置換．",
			"    std::vector<std::vector<int> > cycles() const {",
			"        std::vector<std::vector<int> > res;",
			"        bool seen[order()] = {};",
			"        for(int i = 0; i < order(); ++i) {",
			"            if(seen[i]) continue;",
			"            std::vector<int> cycle({i});",
			"            seen[i] = true;",
			"            int idx = (*this)[i];",
			"            while(!seen[idx]) {",
			"                cycle.push_back(idx);",
			"                seen[idx] = true;",
			"                idx = (*this)[idx];",
			"            }",
			"            res.push_back(cycle);",
			"        }",
			"        return res;",
			"    }",
			"    // 置換符号．",
			"    int sgn() const {",
			"        int res = 1;",
			"        bool seen[order()] = {};",
			"        for(int i = 0; i < order(); ++i) {",
			"            if(seen[i]) continue;",
			"            seen[i] = true;",
			"            int idx = (*this)[i];",
			"            int cnt = 0;",
			"            while(!seen[idx]) {",
			"                cnt++;",
			"                seen[idx] = true;",
			"                idx = (*this)[idx];",
			"            }",
			"            if(cnt % 2 == 1) res *= -1;  // 奇置換である場合．",
			"        }",
			"        return res;",
			"    }",
			"    void init() {",
			"        std::iota(m_perm.begin(), m_perm.end(), 0);",
			"        std::iota(m_inv.begin(), m_inv.end(), 0);",
			"        m_is_inversed = false;",
			"    }",
			"",
			"    auto begin() const { return (m_is_inversed ? m_inv.begin() : m_perm.begin()); }",
			"    auto end() const { return (m_is_inversed ? m_inv.end() : m_perm.end()); }",
			"};",
			"",
			"// 逆置換．",
			"Permutation inv_permutation(const Permutation &P) {",
			"    Permutation inv(P);",
			"    inv.inverse();",
			"    return inv;",
			"}",
			"",
			"// 置換行列．",
			"class Pivot {",
			"    Permutation m_perm;  // m_perm[i]:=(i行目におけるピボットの位置).",
			"",
			"public:",
			"    Pivot() : Pivot(0) {}",
			"    explicit Pivot(int n) : m_perm(n) {}",
			"    explicit Pivot(const std::vector<int> &perm) : m_perm(perm) {}",
			"",
			"    const int &operator[](int i) const {",
			"        assert(0 <= i and i < order());",
			"        return m_perm[i];",
			"    }",
			"    template <typename T>",
			"    Matrix<T> operator*(const Matrix<T> &A) const {",
			"        assert(A.column() == order());",
			"        Matrix<T> R(A.column(), A.row());",
			"        for(int i = 0; i < R.column(); ++i) {",
			"            for(int j = 0; j < R.row(); ++j) R.loc(i, j) = A.loc(m_perm[i], j);",
			"        }",
			"        return R;",
			"    }",
			"    Pivot operator*(const Pivot &pivot) const {",
			"        assert(pivot.order() == order());",
			"        std::vector<int> res(order());",
			"        for(int i = 0; i < order(); ++i) res[i] = pivot[(*this)[i]];",
			"        return Pivot(res);",
			"    }",
			"",
			"    template <typename T>",
			"    friend Matrix<T> operator*(Matrix<T> &A, Pivot &pivot) {",
			"        assert(A.row() == pivot.order());",
			"        A.transpose();",
			"        pivot.inverse();",
			"        auto &&R = pivot * A;",
			"        R.transpose();",
			"        A.transpose();",
			"        pivot.inverse();",
			"        return R;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Pivot &pivot) {",
			"        for(int i = 0; i < pivot.order(); ++i) os << (i == 0 ? \"[\" : \" \") << pivot[i];",
			"        os << \"]\";",
			"        return os;",
			"    }",
			"",
			"    int order() const { return m_perm.order(); }",
			"    void swap(int i, int j) {",
			"        assert(0 <= i and i < order());",
			"        assert(0 <= j and j < order());",
			"        m_perm.swap(i, j);",
			"    }",
			"    void inverse() { m_perm.inverse(); }",
			"    template <typename T>",
			"    void sort(Matrix<T> &A) {",
			"        assert(A.column() == order());",
			"        bool seen[order()] = {};",
			"        for(int i = 0; i < order(); ++i) {",
			"            if(seen[i]) continue;",
			"            int idx = m_perm.inv(i);",
			"            while(idx != i) {",
			"                A.swap(i, idx);",
			"                seen[idx] = true;",
			"                idx = m_perm.inv(idx);",
			"            }",
			"            seen[i] = true;",
			"        }",
			"    }",
			"    template <typename T>",
			"    void reverse(Matrix<T> &A) {",
			"        inverse();",
			"        sort(A);",
			"        inverse();",
			"    }",
			"    int sgn() const { return m_perm.sgn(); }",
			"    void init() { m_perm.init(); }",
			"",
			"    auto begin() const { return m_perm.begin(); }",
			"    auto end() const { return m_perm.end(); }",
			"};",
			"",
			"Pivot inv_pivot(const Pivot &pivot) {",
			"    Pivot inv(pivot);",
			"    inv.inverse();",
			"    return inv;",
			"}",
			"",
			"// PLU分解．O(N^3).",
			"template <typename T>",
			"std::tuple<Pivot, Matrix<T>, Matrix<T>, bool> lu_decomposition(Matrix<T> A) {",
			"    assert(A.column() == A.row());",
			"    const int n = A.column();",
			"    Matrix<T> L(n, n, 0), U(n, n, 0);",
			"    Pivot P(n);",
			"    for(int k = 0; k < n; ++k) {",
			"        int idx = k;",
			"        for(int i = k + 1; i < n; ++i) {",
			"            if(std::abs(A.loc(i, k)) > std::abs(A.loc(idx, k))) idx = i;",
			"        }",
			"        if(std::abs(A.loc(idx, k)) <= EPS) return {P, L, U, false};",
			"        if(idx != k) {",
			"            P.swap(k, idx);",
			"            for(int j = 0; j < k; ++j) {",
			"                std::swap(L.loc(k, j), L.loc(idx, j));",
			"                std::swap(U.loc(k, j), U.loc(idx, j));",
			"            }",
			"            for(int j = k; j < n; ++j) std::swap(A.loc(k, j), A.loc(idx, j));",
			"        }",
			"        auto tmp = 1.0 / A.loc(k, k);",
			"        for(int i = k; i < n; ++i) L.loc(i, k) = A.loc(i, k) * tmp;",
			"        for(int j = k; j < n; ++j) U.loc(k, j) = A.loc(k, j);",
			"        for(int i = k + 1; i < n; ++i) {",
			"            for(int j = k + 1; j < n; ++j) A.loc(i, j) -= L.loc(i, k) * U.loc(k, j);",
			"        }",
			"    }",
			"    return {P, L, U, true};",
			"}",
			"",
			"// サラスの方法．1次，2次，3次の正方行列の行列式を求める．O(N^2).",
			"template <typename T>",
			"T sarrus(const Matrix<T> &A) {",
			"    assert(A.column() == A.row());",
			"    assert(1 <= A.column() and A.column() <= 3);",
			"    if(A.column() == 1) return A.loc(0, 0);                                            // 1次の場合．",
			"    if(A.column() == 2) return A.loc(0, 0) * A.loc(1, 1) - A.loc(0, 1) * A.loc(1, 0);  // 2次の場合．",
			"    // 3次の場合．",
			"    auto a = A.loc(0, 0) * A.loc(1, 1) * A.loc(2, 2) + A.loc(0, 1) * A.loc(1, 2) * A.loc(2, 0) + A.loc(0, 2) * A.loc(1, 0) * A.loc(2, 1);",
			"    auto b = A.loc(0, 2) * A.loc(1, 1) * A.loc(2, 0) + A.loc(0, 1) * A.loc(1, 0) * A.loc(2, 2) + A.loc(0, 0) * A.loc(1, 2) * A.loc(2, 1);",
			"    return a - b;",
			"}",
			"",
			"// 行列式．",
			"template <typename T>",
			"T det(const Matrix<T> &A) {",
			"    assert(A.column() == A.row());",
			"    assert(A.column() > 0);",
			"    if(1 <= A.column() and A.column() <= 3) return sarrus(A);",
			"    const auto &&[P, L, U, success] = lu_decomposition(A);",
			"    if(!success) return 0;",
			"    T res = P.sgn();",
			"    for(int i = 0; i < U.column(); ++i) res *= U.loc(i, i);",
			"    return res;",
			"}",
			"",
			"// 掃き出し法．ガウス・ジョルダンの消去法．返り値は行列の階数．O(N^3).",
			"template <typename T>",
			"int gaussian_elimination(Matrix<T> &sweep) {",
			"    int k = 0, l = 0;",
			"    while(k < sweep.column() and l < sweep.row()) {",
			"        int idx = k;",
			"        for(int i = k + 1; i < sweep.column(); ++i) {",
			"            if(std::abs(sweep.loc(i, l)) > std::abs(sweep.loc(idx, l))) idx = i;",
			"        }",
			"        if(std::abs(sweep.loc(idx, l)) <= EPS) {",
			"            l++;",
			"            continue;",
			"        }",
			"        if(idx != k) {",
			"            for(int j = l; j < sweep.row(); ++j) std::swap(sweep.loc(k, j), sweep.loc(idx, j));",
			"        }",
			"        auto tmp = 1.0 / sweep.loc(k, l);",
			"        for(int j = l; j < sweep.row(); ++j) sweep.loc(k, j) *= tmp;",
			"        for(int i = 0; i < sweep.column(); ++i) {",
			"            if(i == k) continue;",
			"            auto tmp2 = -sweep.loc(i, l);",
			"            for(int j = l; j < sweep.row(); ++j) sweep.loc(i, j) += sweep.loc(k, j) * tmp2;",
			"        }",
			"        k++, l++;",
			"    }",
			"    return k;",
			"}",
			"",
			"// 逆行列．掃き出し法を用いる．O(N^3).",
			"template <typename T>",
			"Matrix<T> inv_matrix(const Matrix<T> &A) {",
			"    assert(A.column() == A.row());",
			"    // assert(det(A) != 0);",
			"    const int n = A.column();",
			"    Matrix<T> sweep(n, 2 * n);",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < n; ++j) {",
			"            sweep.loc(i, j) = A.loc(i, j);",
			"            sweep.loc(i, j + n) = (i == j ? 1 : 0);",
			"        }",
			"    }",
			"    const int rank = gaussian_elimination(sweep);",
			"    assert(rank == n);",
			"    Matrix<T> inv(n, n);",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < n; ++j) inv.loc(i, j) = sweep.loc(i, j + n);",
			"    }",
			"    return inv;",
			"}",
			"",
			"// 連立一次方程式を解く．Linear Simultaneous Equation.",
			"template <typename T>",
			"std::tuple<Matrix<T>, std::vector<int>, int> solve_lse(const Matrix<T> &A, const std::vector<T> &b) {",
			"    assert(A.column() == static_cast<int>(b.size()));",
			"    Matrix<T> res(A.column(), A.row() + 1);",
			"    for(int i = 0; i < A.column(); ++i) {",
			"        for(int j = 0; j < A.row(); ++j) res.loc(i, j) = A.loc(i, j);",
			"        res.loc(i, A.row()) = b[i];",
			"    }",
			"    const int rank = gaussian_elimination(res);",
			"    std::vector<int> posi;",
			"    int i = 0, j = -1;",
			"    for(; i < rank; ++i) {",
			"        for(j = j + 1; j < A.row(); ++j) {",
			"            if(std::abs(res.loc(i, j)) > EPS) {",
			"                posi.push_back(j);",
			"                break;",
			"            }",
			"        }",
			"        if(j == A.row()) break;",
			"    }",
			"    for(; i < rank; ++i) {",
			"        if(std::abs(res.loc(i, A.row())) > EPS) return {res, std::vector<int>(), 0};  // 解なし．",
			"    }",
			"    return {res, posi, rank};",
			"}",
			"",
			"}  // namespace matrix",
			"",
			"// using namespace matrix;"
		],
		"description": ""
	},
	"namespace matrix (Modint)": {
		"scope": "cpp",
		"prefix": "namespace matrix (Modint)",
		"body": [
			"namespace matrix {",
			"",
			"// PLU分解．O(N^3).",
			"template <int mod>",
			"std::tuple<Pivot, Matrix<Modint<mod> >, Matrix<Modint<mod> >, bool> lu_decomposition(Matrix<Modint<mod> > A) {",
			"    assert(A.column() == A.row());",
			"    const int n = A.column();",
			"    Matrix<Modint<mod> > L(n, n, 0), U(n, n, 0);",
			"    Pivot P(n);",
			"    for(int k = 0; k < n; ++k) {",
			"        int idx = k;",
			"        while(idx < n and A.loc(idx, k) == 0) idx++;",
			"        if(idx == n) return {P, L, U, false};",
			"        if(idx != k) {",
			"            P.swap(k, idx);",
			"            for(int j = 0; j < k; ++j) {",
			"                std::swap(L.loc(k, j), L.loc(idx, j));",
			"                std::swap(U.loc(k, j), U.loc(idx, j));",
			"            }",
			"            for(int j = k; j < n; ++j) std::swap(A.loc(k, j), A.loc(idx, j));",
			"        }",
			"        auto tmp = 1 / A.loc(k, k);",
			"        for(int i = k; i < n; ++i) L.loc(i, k) = A.loc(i, k) * tmp;",
			"        for(int j = k; j < n; ++j) U.loc(k, j) = A.loc(k, j);",
			"        for(int i = k + 1; i < n; ++i) {",
			"            for(int j = k + 1; j < n; ++j) A.loc(i, j) -= L.loc(i, k) * U.loc(k, j);",
			"        }",
			"    }",
			"    return {P, L, U, true};",
			"}",
			"",
			"// 掃き出し法．ガウス・ジョルダンの消去法．返り値は行列の階数．O(N^3).",
			"template <int mod>",
			"int gaussian_elimination(Matrix<Modint<mod> > &sweep) {",
			"    int k = 0, l = 0;",
			"    while(k < sweep.column() and l < sweep.row()) {",
			"        int idx = k;",
			"        while(idx < sweep.column() and sweep.loc(idx, l) == 0) idx++;",
			"        if(idx == sweep.column()) {",
			"            l++;",
			"            continue;",
			"        }",
			"        if(idx != k) {",
			"            for(int j = l; j < sweep.row(); ++j) std::swap(sweep.loc(k, j), sweep.loc(idx, j));",
			"        }",
			"        auto tmp = 1 / sweep.loc(k, l);",
			"        for(int j = l; j < sweep.row(); ++j) sweep.loc(k, j) *= tmp;",
			"        for(int i = 0; i < sweep.column(); ++i) {",
			"            if(i == k) continue;",
			"            auto tmp2 = -sweep.loc(i, l);",
			"            for(int j = l; j < sweep.row(); ++j) sweep.loc(i, j) += sweep.loc(k, j) * tmp2;",
			"        }",
			"        k++, l++;",
			"    }",
			"    return k;",
			"}",
			"",
			"// 連立一次方程式を解く．Linear Simultaneous Equation.",
			"template <int mod>",
			"std::tuple<Matrix<Modint<mod> >, std::vector<int>, int> solve_lse(const Matrix<Modint<mod> > &A, const std::vector<Modint<mod> > &b) {",
			"    assert(A.column() == static_cast<int>(b.size()));",
			"    Matrix<Modint<mod> > res(A.column(), A.row() + 1);",
			"    for(int i = 0; i < A.column(); ++i) {",
			"        for(int j = 0; j < A.row(); ++j) res.loc(i, j) = A.loc(i, j);",
			"        res.loc(i, A.row()) = b[i];",
			"    }",
			"    const int rank = gaussian_elimination(res);",
			"    std::vector<int> posi;",
			"    int i = 0, j = -1;",
			"    for(; i < rank; ++i) {",
			"        for(j = j + 1; j < A.row(); ++j) {",
			"            if(res.loc(i, j) != 0) {",
			"                posi.push_back(j);",
			"                break;",
			"            }",
			"        }",
			"        if(j == A.row()) break;",
			"    }",
			"    for(; i < rank; ++i) {",
			"        if(res.loc(i, A.row()) != 0) return {res, std::vector<int>(), 0};  // 解なし．",
			"    }",
			"    return {res, posi, rank};",
			"}",
			"",
			"}  // namespace matrix"
		],
		"description": ""
	}
}