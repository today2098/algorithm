{
	// Place your algorithm ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "Dijkstra",
		"body": [
			"template <typename T>",
			"class Dijkstra {",
			"    template <typename Type>",
			"    using r_priority_queue = std::priority_queue<Type, std::vector<Type>, std::greater<Type> >;",
			"    struct Edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int m_vn;                             // m_vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > m_g;  // m_g[v][]:=(ノードvが始点である有向辺のリスト).",
			"    std::vector<T> m_d;                   // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;               // m_pre[t]:=(ノードtを訪問する直前のノードの番号). 逆方向経路．",
			"    T m_inf;",
			"",
			"public:",
			"    Dijkstra() : Dijkstra(0) {}",
			"    explicit Dijkstra(size_t vn, T inf = 1e9) : m_vn(vn), m_g(vn), m_d(vn, inf), m_pre(vn, -1), m_inf(inf) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    T infinity() const { return m_inf; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < size());",
			"        assert(0 <= to and to < size());",
			"        m_g[from].push_back((Edge){to, cost});",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|E|*log|V|).",
			"    void dijkstra(int s) {",
			"        assert(0 <= s and s < size());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        r_priority_queue<std::pair<T, int> > pque;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(m_d[v] < dist) continue;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(m_d[e.to] > m_d[v] + e.cost) {",
			"                    m_d[e.to] = m_d[v] + e.cost;",
			"                    m_pre[e.to] = v;",
			"                    pque.emplace(m_d[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < size());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> get_path(int t) const {",
			"        assert(0 <= t and t < size());",
			"        std::vector<int> path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "単一始点最短経路"
	},
	"SegmentTree": {
		"scope": "cpp",
		"prefix": "SegmentTree",
		"body": [
			"template <typename T>",
			"class SegmentTree {",
			"    using F = std::function<T(T, T)>;",
			"",
			"    F op;                 // T op(T,T):=(二項演算関数).",
			"    T e;                  // e:=(単位元).",
			"    int sz;               // sz:=(要素数).",
			"    int n;                // n:=(葉の数).",
			"    std::vector<T> tree;  // tree[]:=(完全二分木). 1-based index.",
			"",
			"    void build() {",
			"        n = 1;",
			"        while(n < size()) n <<= 1;",
			"        tree.assign(2 * n, identity());",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    SegmentTree(){};",
			"    explicit SegmentTree(const F &op_, const T &e_, size_t sz_) : op(op_), e(e_), sz(sz_) {",
			"        build();",
			"    }",
			"    explicit SegmentTree(const F &op_, const T &e_, std::vector<T> &v) : op(op_), e(e_), sz(v.size()) {",
			"        build();",
			"        std::copy(v.begin(), v.end(), tree.begin() + n);",
			"        for(int i = n - 1; i >= 1; --i) tree[i] = op(tree[i << 1], tree[(i << 1) | 1]);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return sz; }",
			"    // 単位元を返す．",
			"    T identity() const { return e; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const T &a) {",
			"        assert(0 <= k and k < size());",
			"        k += n;",
			"        tree[k] = a;",
			"        while(k >>= 1) tree[k] = op(tree[k << 1], tree[(k << 1) | 1]);",
			"    }",
			"    // k番目の要素をaを加える．O(logN).",
			"    void add(int k, const T &a) {",
			"        assert(0 <= k and k < size());",
			"        k += n;",
			"        tree[k] += a;",
			"        while(k >>= 1) tree[k] = op(tree[k << 1], tree[(k << 1) | 1]);",
			"    }",
			"    // 一点取得．O(1).",
			"    T prod(int k) const {",
			"        assert(0 <= k and k < size());",
			"        return tree[k + n];",
			"    }",
			"    // 区間[l,r)の総積(v[l]•v[l+1]•....•v[r-1])を求める．O(logN).",
			"    T prod(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        T lv = identity(), rv = identity();",
			"        l += n, r += n;",
			"        while(l < r) {",
			"            if(l & 1) lv = op(lv, tree[l++]);",
			"            if(r & 1) rv = op(tree[--r], rv);",
			"            l >>= 1, r >>= 1;",
			"        }",
			"        return op(lv, rv);",
			"    }",
			"    // 区間全体の総積を返す．O(1).",
			"    T prod_all() const { return tree[1]; }",
			"    // jud(prod(l,-))=trueとなる区間の最右位値を二分探索する．",
			"    // ただし要素列には単調性があり，またjud(e)=trueであること．O(logN).",
			"    int most_right(const std::function<bool(T)> &jud, int l) const {",
			"        assert(jud(identity()) == true);",
			"        assert(0 <= l and l <= size());",
			"        if(l == size()) return size();",
			"        T val = identity();",
			"        l += n;",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            T &&tmp = op(val, tree[l]);",
			"            if(!jud(tmp)) {",
			"                while(l < n) {",
			"                    l <<= 1;",
			"                    T &&tmp2 = op(val, tree[l]);",
			"                    if(jud(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==xのとき，xは2の階乗数．",
			"        return size();",
			"    }",
			"    // jud(prod(-,r))=trueとなる区間の最左位値を二分探索する．",
			"    // ただし要素列には単調性があり，またjud(e)=trueであること．O(logN).",
			"    int most_left(const std::function<bool(T)> &jud, int r) const {",
			"        assert(jud(identity()) == true);",
			"        assert(0 <= r and r <= size());",
			"        if(r == 0) return 0;",
			"        T val = identity();",
			"        r += n;",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            T &&tmp = op(tree[r], val);",
			"            if(!jud(tmp)) {",
			"                while(r < n) {",
			"                    r = (r << 1) | 1;",
			"                    T &&tmp2 = op(tree[r], val);",
			"                    if(jud(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==xのとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() { std::fill(tree.begin(), tree.end(), identity()); }",
			"};"
		],
		"description": ""
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "UnionFind",
		"body": [
			"// 素集合データ構造．",
			"class UnionFind {",
			"    int m_vn;                // m_vn:=(ノード数).",
			"    int m_gn;                // m_gn:=(グループ数).",
			"    std::vector<int> m_par;  // m_par[v]:=(ノードvの親番号). 0未満の場合，vは親で，値の絶対値はグループサイズを表す．",
			"",
			"public:",
			"    UnionFind() : UnionFind(0) {}",
			"    explicit UnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // ノード数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // ノードvの親番号を返す．",
			"    int root(int v) {",
			"        assert(0 <= v and v < vn());",
			"        if(m_par[v] < 0) return v;",
			"        return m_par[v] = root(m_par[v]);",
			"    }",
			"    // ノードvが属するグループのサイズを返す．",
			"    int size(int v) {",
			"        assert(0 <= v and v < vn());",
			"        return -m_par[root(v)];",
			"    }",
			"    // ノードuとvが同じグループか判定する．",
			"    bool same(int u, int v) {",
			"        assert(0 <= u and u < vn());",
			"        assert(0 <= v and v < vn());",
			"        return root(u) == root(v);",
			"    }",
			"    // ノードu, vが属するそれぞれのグループを結合する．",
			"    bool unite(int u, int v) {",
			"        assert(0 <= u and u < vn());",
			"        assert(0 <= v and v < vn());",
			"        u = root(u), v = root(v);",
			"        if(u == v) return false;                // Do nothing.",
			"        if(size(u) < size(v)) std::swap(u, v);  // Merge technique.",
			"        m_par[u] += m_par[v];",
			"        m_par[v] = u;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"    }",
			"};"
		],
		"description": "素集合データ構造"
	}
}